{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst pify = require('pify');\nconst semver = require('semver');\nconst defaults = {\n  mode: 0o777 & ~process.umask(),\n  fs\n};\nconst useNativeRecursiveOption = semver.satisfies(process.version, '>=10.12.0');\n\n// https://github.com/nodejs/node/issues/8987\n// https://github.com/libuv/libuv/pull/1088\nconst checkPath = pth => {\n  if (process.platform === 'win32') {\n    const pathHasInvalidWinCharacters = /[<>:\"|?*]/.test(pth.replace(path.parse(pth).root, ''));\n    if (pathHasInvalidWinCharacters) {\n      const error = new Error(`Path contains invalid characters: ${pth}`);\n      error.code = 'EINVAL';\n      throw error;\n    }\n  }\n};\nconst permissionError = pth => {\n  // This replicates the exception of `fs.mkdir` with native the\n  // `recusive` option when run on an invalid drive under Windows.\n  const error = new Error(`operation not permitted, mkdir '${pth}'`);\n  error.code = 'EPERM';\n  error.errno = -4048;\n  error.path = pth;\n  error.syscall = 'mkdir';\n  return error;\n};\nconst makeDir = (input, options) => Promise.resolve().then(() => {\n  checkPath(input);\n  options = Object.assign({}, defaults, options);\n\n  // TODO: Use util.promisify when targeting Node.js 8\n  const mkdir = pify(options.fs.mkdir);\n  const stat = pify(options.fs.stat);\n  if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {\n    const pth = path.resolve(input);\n    return mkdir(pth, {\n      mode: options.mode,\n      recursive: true\n    }).then(() => pth);\n  }\n  const make = pth => {\n    return mkdir(pth, options.mode).then(() => pth).catch(error => {\n      if (error.code === 'EPERM') {\n        throw error;\n      }\n      if (error.code === 'ENOENT') {\n        if (path.dirname(pth) === pth) {\n          throw permissionError(pth);\n        }\n        if (error.message.includes('null bytes')) {\n          throw error;\n        }\n        return make(path.dirname(pth)).then(() => make(pth));\n      }\n      return stat(pth).then(stats => stats.isDirectory() ? pth : Promise.reject()).catch(() => {\n        throw error;\n      });\n    });\n  };\n  return make(path.resolve(input));\n});\nmodule.exports = makeDir;\nmodule.exports.default = makeDir;\nmodule.exports.sync = (input, options) => {\n  checkPath(input);\n  options = Object.assign({}, defaults, options);\n  if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {\n    const pth = path.resolve(input);\n    fs.mkdirSync(pth, {\n      mode: options.mode,\n      recursive: true\n    });\n    return pth;\n  }\n  const make = pth => {\n    try {\n      options.fs.mkdirSync(pth, options.mode);\n    } catch (error) {\n      if (error.code === 'EPERM') {\n        throw error;\n      }\n      if (error.code === 'ENOENT') {\n        if (path.dirname(pth) === pth) {\n          throw permissionError(pth);\n        }\n        if (error.message.includes('null bytes')) {\n          throw error;\n        }\n        make(path.dirname(pth));\n        return make(pth);\n      }\n      try {\n        if (!options.fs.statSync(pth).isDirectory()) {\n          throw new Error('The path is not a directory');\n        }\n      } catch (_) {\n        throw error;\n      }\n    }\n    return pth;\n  };\n  return make(path.resolve(input));\n};","map":null,"metadata":{},"sourceType":"script"}