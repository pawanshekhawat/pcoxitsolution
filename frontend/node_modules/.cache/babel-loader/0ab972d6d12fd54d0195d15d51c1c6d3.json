{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _terser = require(\"terser\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nconst buildTerserOptions = ({\n  ecma,\n  warnings,\n  parse = {},\n  compress = {},\n  mangle,\n  module,\n  output,\n  toplevel,\n  nameCache,\n  ie8,\n  /* eslint-disable camelcase */\n  keep_classnames,\n  keep_fnames,\n  /* eslint-enable camelcase */\n  safari10\n} = {}) => ({\n  ecma,\n  warnings,\n  parse: _objectSpread({}, parse),\n  compress: typeof compress === 'boolean' ? compress : _objectSpread({}, compress),\n  // eslint-disable-next-line no-nested-ternary\n  mangle: mangle == null ? true : typeof mangle === 'boolean' ? mangle : _objectSpread({}, mangle),\n  output: _objectSpread({\n    shebang: true,\n    comments: false,\n    beautify: false,\n    semicolons: true\n  }, output),\n  module,\n  // Ignoring sourceMap from options\n  sourceMap: null,\n  toplevel,\n  nameCache,\n  ie8,\n  keep_classnames,\n  keep_fnames,\n  safari10\n});\nconst buildComments = (options, terserOptions, extractedComments) => {\n  const condition = {};\n  const commentsOpts = terserOptions.output.comments; // Use /^\\**!|@preserve|@license|@cc_on/i RegExp\n\n  if (typeof options.extractComments === 'boolean') {\n    condition.preserve = commentsOpts;\n    condition.extract = /^\\**!|@preserve|@license|@cc_on/i;\n  } else if (typeof options.extractComments === 'string' || options.extractComments instanceof RegExp) {\n    // extractComments specifies the extract condition and commentsOpts specifies the preserve condition\n    condition.preserve = commentsOpts;\n    condition.extract = options.extractComments;\n  } else if (typeof options.extractComments === 'function') {\n    condition.preserve = commentsOpts;\n    condition.extract = options.extractComments;\n  } else if (Object.prototype.hasOwnProperty.call(options.extractComments, 'condition')) {\n    // Extract condition is given in extractComments.condition\n    condition.preserve = commentsOpts;\n    condition.extract = options.extractComments.condition;\n  } else {\n    // No extract condition is given. Extract comments that match commentsOpts instead of preserving them\n    condition.preserve = false;\n    condition.extract = commentsOpts;\n  } // Ensure that both conditions are functions\n\n  ['preserve', 'extract'].forEach(key => {\n    let regexStr;\n    let regex;\n    switch (typeof condition[key]) {\n      case 'boolean':\n        condition[key] = condition[key] ? () => true : () => false;\n        break;\n      case 'function':\n        break;\n      case 'string':\n        if (condition[key] === 'all') {\n          condition[key] = () => true;\n          break;\n        }\n        if (condition[key] === 'some') {\n          condition[key] = (astNode, comment) => {\n            return comment.type === 'comment2' && /^\\**!|@preserve|@license|@cc_on/i.test(comment.value);\n          };\n          break;\n        }\n        regexStr = condition[key];\n        condition[key] = (astNode, comment) => {\n          return new RegExp(regexStr).test(comment.value);\n        };\n        break;\n      default:\n        regex = condition[key];\n        condition[key] = (astNode, comment) => regex.test(comment.value);\n    }\n  }); // Redefine the comments function to extract and preserve\n  // comments according to the two conditions\n\n  return (astNode, comment) => {\n    if (condition.extract(astNode, comment)) {\n      const commentText = comment.type === 'comment2' ? `/*${comment.value}*/` : `//${comment.value}`; // Don't include duplicate comments\n\n      if (!extractedComments.includes(commentText)) {\n        extractedComments.push(commentText);\n      }\n    }\n    return condition.preserve(astNode, comment);\n  };\n};\nconst minify = options => {\n  const {\n    file,\n    input,\n    inputSourceMap,\n    extractComments,\n    minify: minifyFn\n  } = options;\n  if (minifyFn) {\n    return minifyFn({\n      [file]: input\n    }, inputSourceMap);\n  } // Copy terser options\n\n  const terserOptions = buildTerserOptions(options.terserOptions); // Let terser generate a SourceMap\n\n  if (inputSourceMap) {\n    terserOptions.sourceMap = true;\n  }\n  const extractedComments = [];\n  if (extractComments) {\n    terserOptions.output.comments = buildComments(options, terserOptions, extractedComments);\n  }\n  const {\n    error,\n    map,\n    code,\n    warnings\n  } = (0, _terser.minify)({\n    [file]: input\n  }, terserOptions);\n  return {\n    error,\n    map,\n    code,\n    warnings,\n    extractedComments\n  };\n};\nvar _default = minify;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}