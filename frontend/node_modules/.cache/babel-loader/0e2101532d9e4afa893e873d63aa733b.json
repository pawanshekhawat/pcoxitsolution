{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\nconst ModuleHotAcceptDependency = require(\"../dependencies/ModuleHotAcceptDependency\");\nconst ModuleHotDeclineDependency = require(\"../dependencies/ModuleHotDeclineDependency\");\nconst ConcatenatedModule = require(\"./ConcatenatedModule\");\nconst HarmonyCompatibilityDependency = require(\"../dependencies/HarmonyCompatibilityDependency\");\nconst StackedSetMap = require(\"../util/StackedSetMap\");\nconst formatBailoutReason = msg => {\n  return \"ModuleConcatenation bailout: \" + msg;\n};\nclass ModuleConcatenationPlugin {\n  constructor(options) {\n    if (typeof options !== \"object\") options = {};\n    this.options = options;\n  }\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      const handler = (parser, parserOptions) => {\n        parser.hooks.call.for(\"eval\").tap(\"ModuleConcatenationPlugin\", () => {\n          // Because of variable renaming we can't use modules with eval.\n          parser.state.module.buildMeta.moduleConcatenationBailout = \"eval()\";\n        });\n      };\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"ModuleConcatenationPlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"ModuleConcatenationPlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/esm\").tap(\"ModuleConcatenationPlugin\", handler);\n      const bailoutReasonMap = new Map();\n      const setBailoutReason = (module, reason) => {\n        bailoutReasonMap.set(module, reason);\n        module.optimizationBailout.push(typeof reason === \"function\" ? rs => formatBailoutReason(reason(rs)) : formatBailoutReason(reason));\n      };\n      const getBailoutReason = (module, requestShortener) => {\n        const reason = bailoutReasonMap.get(module);\n        if (typeof reason === \"function\") return reason(requestShortener);\n        return reason;\n      };\n      compilation.hooks.optimizeChunkModules.tap(\"ModuleConcatenationPlugin\", (chunks, modules) => {\n        const relevantModules = [];\n        const possibleInners = new Set();\n        for (const module of modules) {\n          // Only harmony modules are valid for optimization\n          if (!module.buildMeta || module.buildMeta.exportsType !== \"namespace\" || !module.dependencies.some(d => d instanceof HarmonyCompatibilityDependency)) {\n            setBailoutReason(module, \"Module is not an ECMAScript module\");\n            continue;\n          }\n\n          // Some expressions are not compatible with module concatenation\n          // because they may produce unexpected results. The plugin bails out\n          // if some were detected upfront.\n          if (module.buildMeta && module.buildMeta.moduleConcatenationBailout) {\n            setBailoutReason(module, `Module uses ${module.buildMeta.moduleConcatenationBailout}`);\n            continue;\n          }\n\n          // Exports must be known (and not dynamic)\n          if (!Array.isArray(module.buildMeta.providedExports)) {\n            setBailoutReason(module, \"Module exports are unknown\");\n            continue;\n          }\n\n          // Using dependency variables is not possible as this wraps the code in a function\n          if (module.variables.length > 0) {\n            setBailoutReason(module, `Module uses injected variables (${module.variables.map(v => v.name).join(\", \")})`);\n            continue;\n          }\n\n          // Hot Module Replacement need it's own module to work correctly\n          if (module.dependencies.some(dep => dep instanceof ModuleHotAcceptDependency || dep instanceof ModuleHotDeclineDependency)) {\n            setBailoutReason(module, \"Module uses Hot Module Replacement\");\n            continue;\n          }\n          relevantModules.push(module);\n\n          // Module must not be the entry points\n          if (module.isEntryModule()) {\n            setBailoutReason(module, \"Module is an entry point\");\n            continue;\n          }\n\n          // Module must be in any chunk (we don't want to do useless work)\n          if (module.getNumberOfChunks() === 0) {\n            setBailoutReason(module, \"Module is not in any chunk\");\n            continue;\n          }\n\n          // Module must only be used by Harmony Imports\n          const nonHarmonyReasons = module.reasons.filter(reason => !reason.dependency || !(reason.dependency instanceof HarmonyImportDependency));\n          if (nonHarmonyReasons.length > 0) {\n            const importingModules = new Set(nonHarmonyReasons.map(r => r.module).filter(Boolean));\n            const importingExplanations = new Set(nonHarmonyReasons.map(r => r.explanation).filter(Boolean));\n            const importingModuleTypes = new Map(Array.from(importingModules).map(m => /** @type {[string, Set]} */[m, new Set(nonHarmonyReasons.filter(r => r.module === m).map(r => r.dependency.type).sort())]));\n            setBailoutReason(module, requestShortener => {\n              const names = Array.from(importingModules).map(m => `${m.readableIdentifier(requestShortener)} (referenced with ${Array.from(importingModuleTypes.get(m)).join(\", \")})`).sort();\n              const explanations = Array.from(importingExplanations).sort();\n              if (names.length > 0 && explanations.length === 0) {\n                return `Module is referenced from these modules with unsupported syntax: ${names.join(\", \")}`;\n              } else if (names.length === 0 && explanations.length > 0) {\n                return `Module is referenced by: ${explanations.join(\", \")}`;\n              } else if (names.length > 0 && explanations.length > 0) {\n                return `Module is referenced from these modules with unsupported syntax: ${names.join(\", \")} and by: ${explanations.join(\", \")}`;\n              } else {\n                return \"Module is referenced in a unsupported way\";\n              }\n            });\n            continue;\n          }\n          possibleInners.add(module);\n        }\n        // sort by depth\n        // modules with lower depth are more likely suited as roots\n        // this improves performance, because modules already selected as inner are skipped\n        relevantModules.sort((a, b) => {\n          return a.depth - b.depth;\n        });\n        const concatConfigurations = [];\n        const usedAsInner = new Set();\n        for (const currentRoot of relevantModules) {\n          // when used by another configuration as inner:\n          // the other configuration is better and we can skip this one\n          if (usedAsInner.has(currentRoot)) continue;\n\n          // create a configuration with the root\n          const currentConfiguration = new ConcatConfiguration(currentRoot);\n\n          // cache failures to add modules\n          const failureCache = new Map();\n\n          // try to add all imports\n          for (const imp of this._getImports(compilation, currentRoot)) {\n            const problem = this._tryToAdd(compilation, currentConfiguration, imp, possibleInners, failureCache);\n            if (problem) {\n              failureCache.set(imp, problem);\n              currentConfiguration.addWarning(imp, problem);\n            }\n          }\n          if (!currentConfiguration.isEmpty()) {\n            concatConfigurations.push(currentConfiguration);\n            for (const module of currentConfiguration.getModules()) {\n              if (module !== currentConfiguration.rootModule) {\n                usedAsInner.add(module);\n              }\n            }\n          }\n        }\n        // HACK: Sort configurations by length and start with the longest one\n        // to get the biggers groups possible. Used modules are marked with usedModules\n        // TODO: Allow to reuse existing configuration while trying to add dependencies.\n        // This would improve performance. O(n^2) -> O(n)\n        concatConfigurations.sort((a, b) => {\n          return b.modules.size - a.modules.size;\n        });\n        const usedModules = new Set();\n        for (const concatConfiguration of concatConfigurations) {\n          if (usedModules.has(concatConfiguration.rootModule)) continue;\n          const modules = concatConfiguration.getModules();\n          const rootModule = concatConfiguration.rootModule;\n          const newModule = new ConcatenatedModule(rootModule, Array.from(modules), ConcatenatedModule.createConcatenationList(rootModule, modules, compilation));\n          for (const warning of concatConfiguration.getWarningsSorted()) {\n            newModule.optimizationBailout.push(requestShortener => {\n              const reason = getBailoutReason(warning[0], requestShortener);\n              const reasonWithPrefix = reason ? ` (<- ${reason})` : \"\";\n              if (warning[0] === warning[1]) {\n                return formatBailoutReason(`Cannot concat with ${warning[0].readableIdentifier(requestShortener)}${reasonWithPrefix}`);\n              } else {\n                return formatBailoutReason(`Cannot concat with ${warning[0].readableIdentifier(requestShortener)} because of ${warning[1].readableIdentifier(requestShortener)}${reasonWithPrefix}`);\n              }\n            });\n          }\n          const chunks = concatConfiguration.rootModule.getChunks();\n          for (const m of modules) {\n            usedModules.add(m);\n            for (const chunk of chunks) {\n              chunk.removeModule(m);\n            }\n          }\n          for (const chunk of chunks) {\n            chunk.addModule(newModule);\n            newModule.addChunk(chunk);\n            if (chunk.entryModule === concatConfiguration.rootModule) {\n              chunk.entryModule = newModule;\n            }\n          }\n          compilation.modules.push(newModule);\n          for (const reason of newModule.reasons) {\n            if (reason.dependency.module === concatConfiguration.rootModule) reason.dependency.module = newModule;\n            if (reason.dependency.redirectedModule === concatConfiguration.rootModule) reason.dependency.redirectedModule = newModule;\n          }\n          // TODO: remove when LTS node version contains fixed v8 version\n          // @see https://github.com/webpack/webpack/pull/6613\n          // Turbofan does not correctly inline for-of loops with polymorphic input arrays.\n          // Work around issue by using a standard for loop and assigning dep.module.reasons\n          for (let i = 0; i < newModule.dependencies.length; i++) {\n            let dep = newModule.dependencies[i];\n            if (dep.module) {\n              let reasons = dep.module.reasons;\n              for (let j = 0; j < reasons.length; j++) {\n                let reason = reasons[j];\n                if (reason.dependency === dep) {\n                  reason.module = newModule;\n                }\n              }\n            }\n          }\n        }\n        compilation.modules = compilation.modules.filter(m => !usedModules.has(m));\n      });\n    });\n  }\n  _getImports(compilation, module) {\n    return new Set(module.dependencies\n\n    // Get reference info only for harmony Dependencies\n    .map(dep => {\n      if (!(dep instanceof HarmonyImportDependency)) return null;\n      if (!compilation) return dep.getReference();\n      return compilation.getDependencyReference(module, dep);\n    })\n\n    // Reference is valid and has a module\n    // Dependencies are simple enough to concat them\n    .filter(ref => ref && ref.module && (Array.isArray(ref.importedNames) || Array.isArray(ref.module.buildMeta.providedExports)))\n\n    // Take the imported module\n    .map(ref => ref.module));\n  }\n  _tryToAdd(compilation, config, module, possibleModules, failureCache) {\n    const cacheEntry = failureCache.get(module);\n    if (cacheEntry) {\n      return cacheEntry;\n    }\n\n    // Already added?\n    if (config.has(module)) {\n      return null;\n    }\n\n    // Not possible to add?\n    if (!possibleModules.has(module)) {\n      failureCache.set(module, module); // cache failures for performance\n      return module;\n    }\n\n    // module must be in the same chunks\n    if (!config.rootModule.hasEqualsChunks(module)) {\n      failureCache.set(module, module); // cache failures for performance\n      return module;\n    }\n\n    // Clone config to make experimental changes\n    const testConfig = config.clone();\n\n    // Add the module\n    testConfig.add(module);\n\n    // Every module which depends on the added module must be in the configuration too.\n    for (const reason of module.reasons) {\n      // Modules that are not used can be ignored\n      if (reason.module.factoryMeta.sideEffectFree && reason.module.used === false) continue;\n      const problem = this._tryToAdd(compilation, testConfig, reason.module, possibleModules, failureCache);\n      if (problem) {\n        failureCache.set(module, problem); // cache failures for performance\n        return problem;\n      }\n    }\n\n    // Commit experimental changes\n    config.set(testConfig);\n\n    // Eagerly try to add imports too if possible\n    for (const imp of this._getImports(compilation, module)) {\n      const problem = this._tryToAdd(compilation, config, imp, possibleModules, failureCache);\n      if (problem) {\n        config.addWarning(imp, problem);\n      }\n    }\n    return null;\n  }\n}\nclass ConcatConfiguration {\n  constructor(rootModule, cloneFrom) {\n    this.rootModule = rootModule;\n    if (cloneFrom) {\n      this.modules = cloneFrom.modules.createChild(5);\n      this.warnings = cloneFrom.warnings.createChild(5);\n    } else {\n      this.modules = new StackedSetMap();\n      this.modules.add(rootModule);\n      this.warnings = new StackedSetMap();\n    }\n  }\n  add(module) {\n    this.modules.add(module);\n  }\n  has(module) {\n    return this.modules.has(module);\n  }\n  isEmpty() {\n    return this.modules.size === 1;\n  }\n  addWarning(module, problem) {\n    this.warnings.set(module, problem);\n  }\n  getWarningsSorted() {\n    return new Map(this.warnings.asPairArray().sort((a, b) => {\n      const ai = a[0].identifier();\n      const bi = b[0].identifier();\n      if (ai < bi) return -1;\n      if (ai > bi) return 1;\n      return 0;\n    }));\n  }\n  getModules() {\n    return this.modules.asSet();\n  }\n  clone() {\n    return new ConcatConfiguration(this.rootModule, this);\n  }\n  set(config) {\n    this.rootModule = config.rootModule;\n    this.modules = config.modules;\n    this.warnings = config.warnings;\n  }\n}\nmodule.exports = ModuleConcatenationPlugin;","map":null,"metadata":{},"sourceType":"script"}