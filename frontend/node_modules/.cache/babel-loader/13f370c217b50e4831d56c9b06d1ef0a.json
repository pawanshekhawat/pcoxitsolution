{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../schemas/plugins/ProgressPlugin.json\");\n\n/** @typedef {import(\"../declarations/plugins/ProgressPlugin\").ProgressPluginArgument} ProgressPluginArgument */\n/** @typedef {import(\"../declarations/plugins/ProgressPlugin\").ProgressPluginOptions} ProgressPluginOptions */\n\nconst createDefaultHandler = profile => {\n  let lineCaretPosition = 0;\n  let lastMessage = \"\";\n  let lastState;\n  let lastStateTime;\n  const defaultHandler = (percentage, msg, ...args) => {\n    let state = msg;\n    const details = args;\n    if (percentage < 1) {\n      percentage = Math.floor(percentage * 100);\n      msg = `${percentage}% ${msg}`;\n      if (percentage < 100) {\n        msg = ` ${msg}`;\n      }\n      if (percentage < 10) {\n        msg = ` ${msg}`;\n      }\n      for (let detail of details) {\n        if (!detail) continue;\n        if (detail.length > 40) {\n          detail = `...${detail.substr(detail.length - 39)}`;\n        }\n        msg += ` ${detail}`;\n      }\n    }\n    if (profile) {\n      state = state.replace(/^\\d+\\/\\d+\\s+/, \"\");\n      if (percentage === 0) {\n        lastState = null;\n        lastStateTime = Date.now();\n      } else if (state !== lastState || percentage === 1) {\n        const now = Date.now();\n        if (lastState) {\n          const stateMsg = `${now - lastStateTime}ms ${lastState}`;\n          goToLineStart(stateMsg);\n          process.stderr.write(stateMsg + \"\\n\");\n          lineCaretPosition = 0;\n        }\n        lastState = state;\n        lastStateTime = now;\n      }\n    }\n    if (lastMessage !== msg) {\n      goToLineStart(msg);\n      process.stderr.write(msg);\n      lastMessage = msg;\n    }\n  };\n  const goToLineStart = nextMessage => {\n    let str = \"\";\n    for (; lineCaretPosition > nextMessage.length; lineCaretPosition--) {\n      str += \"\\b \\b\";\n    }\n    for (var i = 0; i < lineCaretPosition; i++) {\n      str += \"\\b\";\n    }\n    lineCaretPosition = nextMessage.length;\n    if (str) process.stderr.write(str);\n  };\n  return defaultHandler;\n};\nclass ProgressPlugin {\n  /**\n   * @param {ProgressPluginArgument} options options\n   */\n  constructor(options) {\n    if (typeof options === \"function\") {\n      options = {\n        handler: options\n      };\n    }\n    options = options || {};\n    validateOptions(schema, options, \"Progress Plugin\");\n    options = Object.assign({}, ProgressPlugin.defaultOptions, options);\n    this.profile = options.profile;\n    this.handler = options.handler;\n    this.modulesCount = options.modulesCount;\n    this.showEntries = options.entries;\n    this.showModules = options.modules;\n    this.showActiveModules = options.activeModules;\n  }\n  apply(compiler) {\n    const {\n      modulesCount\n    } = this;\n    const handler = this.handler || createDefaultHandler(this.profile);\n    const showEntries = this.showEntries;\n    const showModules = this.showModules;\n    const showActiveModules = this.showActiveModules;\n    if (compiler.compilers) {\n      const states = new Array(compiler.compilers.length);\n      compiler.compilers.forEach((compiler, idx) => {\n        new ProgressPlugin((p, msg, ...args) => {\n          states[idx] = [p, msg, ...args];\n          handler(states.map(state => state && state[0] || 0).reduce((a, b) => a + b) / states.length, `[${idx}] ${msg}`, ...args);\n        }).apply(compiler);\n      });\n    } else {\n      let lastModulesCount = 0;\n      let lastEntriesCount = 0;\n      let moduleCount = modulesCount;\n      let entriesCount = 1;\n      let doneModules = 0;\n      let doneEntries = 0;\n      const activeModules = new Set();\n      let lastActiveModule = \"\";\n      const update = () => {\n        const percentByModules = doneModules / Math.max(lastModulesCount, moduleCount);\n        const percentByEntries = doneEntries / Math.max(lastEntriesCount, entriesCount);\n        const items = [0.1 + Math.max(percentByModules, percentByEntries) * 0.6, \"building\"];\n        if (showEntries) {\n          items.push(`${doneEntries}/${entriesCount} entries`);\n        }\n        if (showModules) {\n          items.push(`${doneModules}/${moduleCount} modules`);\n        }\n        if (showActiveModules) {\n          items.push(`${activeModules.size} active`);\n          items.push(lastActiveModule);\n        }\n        handler(...items);\n      };\n      const moduleAdd = module => {\n        moduleCount++;\n        if (showActiveModules) {\n          const ident = module.identifier();\n          if (ident) {\n            activeModules.add(ident);\n            lastActiveModule = ident;\n          }\n        }\n        update();\n      };\n      const entryAdd = (entry, name) => {\n        entriesCount++;\n        update();\n      };\n      const moduleDone = module => {\n        doneModules++;\n        if (showActiveModules) {\n          const ident = module.identifier();\n          if (ident) {\n            activeModules.delete(ident);\n            if (lastActiveModule === ident) {\n              lastActiveModule = \"\";\n              for (const m of activeModules) {\n                lastActiveModule = m;\n              }\n            }\n          }\n        }\n        update();\n      };\n      const entryDone = (entry, name) => {\n        doneEntries++;\n        update();\n      };\n      compiler.hooks.compilation.tap(\"ProgressPlugin\", compilation => {\n        if (compilation.compiler.isChild()) return;\n        lastModulesCount = moduleCount;\n        lastEntriesCount = entriesCount;\n        moduleCount = entriesCount = 0;\n        doneModules = doneEntries = 0;\n        handler(0, \"compiling\");\n        compilation.hooks.buildModule.tap(\"ProgressPlugin\", moduleAdd);\n        compilation.hooks.failedModule.tap(\"ProgressPlugin\", moduleDone);\n        compilation.hooks.succeedModule.tap(\"ProgressPlugin\", moduleDone);\n        compilation.hooks.addEntry.tap(\"ProgressPlugin\", entryAdd);\n        compilation.hooks.failedEntry.tap(\"ProgressPlugin\", entryDone);\n        compilation.hooks.succeedEntry.tap(\"ProgressPlugin\", entryDone);\n        const hooks = {\n          finishModules: \"finish module graph\",\n          seal: \"sealing\",\n          beforeChunks: \"chunk graph\",\n          afterChunks: \"after chunk graph\",\n          optimizeDependenciesBasic: \"basic dependencies optimization\",\n          optimizeDependencies: \"dependencies optimization\",\n          optimizeDependenciesAdvanced: \"advanced dependencies optimization\",\n          afterOptimizeDependencies: \"after dependencies optimization\",\n          optimize: \"optimizing\",\n          optimizeModulesBasic: \"basic module optimization\",\n          optimizeModules: \"module optimization\",\n          optimizeModulesAdvanced: \"advanced module optimization\",\n          afterOptimizeModules: \"after module optimization\",\n          optimizeChunksBasic: \"basic chunk optimization\",\n          optimizeChunks: \"chunk optimization\",\n          optimizeChunksAdvanced: \"advanced chunk optimization\",\n          afterOptimizeChunks: \"after chunk optimization\",\n          optimizeTree: \"module and chunk tree optimization\",\n          afterOptimizeTree: \"after module and chunk tree optimization\",\n          optimizeChunkModulesBasic: \"basic chunk modules optimization\",\n          optimizeChunkModules: \"chunk modules optimization\",\n          optimizeChunkModulesAdvanced: \"advanced chunk modules optimization\",\n          afterOptimizeChunkModules: \"after chunk modules optimization\",\n          reviveModules: \"module reviving\",\n          optimizeModuleOrder: \"module order optimization\",\n          advancedOptimizeModuleOrder: \"advanced module order optimization\",\n          beforeModuleIds: \"before module ids\",\n          moduleIds: \"module ids\",\n          optimizeModuleIds: \"module id optimization\",\n          afterOptimizeModuleIds: \"module id optimization\",\n          reviveChunks: \"chunk reviving\",\n          optimizeChunkOrder: \"chunk order optimization\",\n          beforeChunkIds: \"before chunk ids\",\n          optimizeChunkIds: \"chunk id optimization\",\n          afterOptimizeChunkIds: \"after chunk id optimization\",\n          recordModules: \"record modules\",\n          recordChunks: \"record chunks\",\n          beforeHash: \"hashing\",\n          contentHash: \"content hashing\",\n          afterHash: \"after hashing\",\n          recordHash: \"record hash\",\n          beforeModuleAssets: \"module assets processing\",\n          beforeChunkAssets: \"chunk assets processing\",\n          additionalChunkAssets: \"additional chunk assets processing\",\n          record: \"recording\",\n          additionalAssets: \"additional asset processing\",\n          optimizeChunkAssets: \"chunk asset optimization\",\n          afterOptimizeChunkAssets: \"after chunk asset optimization\",\n          optimizeAssets: \"asset optimization\",\n          afterOptimizeAssets: \"after asset optimization\",\n          afterSeal: \"after seal\"\n        };\n        const numberOfHooks = Object.keys(hooks).length;\n        Object.keys(hooks).forEach((name, idx) => {\n          const title = hooks[name];\n          const percentage = idx / numberOfHooks * 0.25 + 0.7;\n          compilation.hooks[name].intercept({\n            name: \"ProgressPlugin\",\n            context: true,\n            call: () => {\n              handler(percentage, title);\n            },\n            tap: (context, tap) => {\n              if (context) {\n                // p is percentage from 0 to 1\n                // args is any number of messages in a hierarchical matter\n                context.reportProgress = (p, ...args) => {\n                  handler(percentage, title, tap.name, ...args);\n                };\n              }\n              handler(percentage, title, tap.name);\n            }\n          });\n        });\n      });\n      compiler.hooks.emit.intercept({\n        name: \"ProgressPlugin\",\n        context: true,\n        call: () => {\n          handler(0.95, \"emitting\");\n        },\n        tap: (context, tap) => {\n          if (context) {\n            context.reportProgress = (p, ...args) => {\n              handler(0.95, \"emitting\", tap.name, ...args);\n            };\n          }\n          handler(0.95, \"emitting\", tap.name);\n        }\n      });\n      compiler.hooks.afterEmit.intercept({\n        name: \"ProgressPlugin\",\n        context: true,\n        call: () => {\n          handler(0.98, \"after emitting\");\n        },\n        tap: (context, tap) => {\n          if (context) {\n            context.reportProgress = (p, ...args) => {\n              handler(0.98, \"after emitting\", tap.name, ...args);\n            };\n          }\n          handler(0.98, \"after emitting\", tap.name);\n        }\n      });\n      compiler.hooks.done.tap(\"ProgressPlugin\", () => {\n        handler(1, \"\");\n      });\n    }\n  }\n}\nProgressPlugin.defaultOptions = {\n  profile: false,\n  modulesCount: 500,\n  modules: true,\n  activeModules: true,\n  // TODO webpack 5 default this to true\n  entries: false\n};\nmodule.exports = ProgressPlugin;","map":null,"metadata":{},"sourceType":"script"}