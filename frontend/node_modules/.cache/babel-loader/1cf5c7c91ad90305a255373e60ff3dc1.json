{"ast":null,"code":"const cache = new Map();\nconst fs = require('fs');\nconst {\n  dirname,\n  resolve\n} = require('path');\nconst lstat = path => new Promise((res, rej) => fs.lstat(path, (er, st) => er ? rej(er) : res(st)));\nconst inferOwner = path => {\n  path = resolve(path);\n  if (cache.has(path)) return Promise.resolve(cache.get(path));\n  const statThen = st => {\n    const {\n      uid,\n      gid\n    } = st;\n    cache.set(path, {\n      uid,\n      gid\n    });\n    return {\n      uid,\n      gid\n    };\n  };\n  const parent = dirname(path);\n  const parentTrap = parent === path ? null : er => {\n    return inferOwner(parent).then(owner => {\n      cache.set(path, owner);\n      return owner;\n    });\n  };\n  return lstat(path).then(statThen, parentTrap);\n};\nconst inferOwnerSync = path => {\n  path = resolve(path);\n  if (cache.has(path)) return cache.get(path);\n  const parent = dirname(path);\n\n  // avoid obscuring call site by re-throwing\n  // \"catch\" the error by returning from a finally,\n  // only if we're not at the root, and the parent call works.\n  let threw = true;\n  try {\n    const st = fs.lstatSync(path);\n    threw = false;\n    const {\n      uid,\n      gid\n    } = st;\n    cache.set(path, {\n      uid,\n      gid\n    });\n    return {\n      uid,\n      gid\n    };\n  } finally {\n    if (threw && parent !== path) {\n      const owner = inferOwnerSync(parent);\n      cache.set(path, owner);\n      return owner; // eslint-disable-line no-unsafe-finally\n    }\n  }\n};\n\nconst inflight = new Map();\nmodule.exports = path => {\n  path = resolve(path);\n  if (inflight.has(path)) return Promise.resolve(inflight.get(path));\n  const p = inferOwner(path).then(owner => {\n    inflight.delete(path);\n    return owner;\n  });\n  inflight.set(path, p);\n  return p;\n};\nmodule.exports.sync = inferOwnerSync;\nmodule.exports.clearCache = () => {\n  cache.clear();\n  inflight.clear();\n};","map":null,"metadata":{},"sourceType":"script"}