{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst ContextDependencyHelpers = exports;\n\n/**\n * Escapes regular expression metacharacters\n * @param {string} str String to quote\n * @returns {string} Escaped string\n */\nconst quotemeta = str => {\n  return str.replace(/[-[\\]\\\\/{}()*+?.^$|]/g, \"\\\\$&\");\n};\nconst splitContextFromPrefix = prefix => {\n  const idx = prefix.lastIndexOf(\"/\");\n  let context = \".\";\n  if (idx >= 0) {\n    context = prefix.substr(0, idx);\n    prefix = `.${prefix.substr(idx)}`;\n  }\n  return {\n    context,\n    prefix\n  };\n};\nconst splitQueryFromPostfix = postfix => {\n  const idx = postfix.indexOf(\"?\");\n  let query = \"\";\n  if (idx >= 0) {\n    query = postfix.substr(idx);\n    postfix = postfix.substr(0, idx);\n  }\n  return {\n    postfix,\n    query\n  };\n};\nContextDependencyHelpers.create = (Dep, range, param, expr, options, contextOptions,\n// when parser is not passed in, expressions won't be walked\nparser = null) => {\n  if (param.isTemplateString()) {\n    let prefixRaw = param.quasis[0].string;\n    let postfixRaw = param.quasis.length > 1 ? param.quasis[param.quasis.length - 1].string : \"\";\n    const valueRange = param.range;\n    const {\n      context,\n      prefix\n    } = splitContextFromPrefix(prefixRaw);\n    const {\n      postfix,\n      query\n    } = splitQueryFromPostfix(postfixRaw);\n\n    // When there are more than two quasis, the generated RegExp can be more precise\n    // We join the quasis with the expression regexp\n    const innerQuasis = param.quasis.slice(1, param.quasis.length - 1);\n    const innerRegExp = options.wrappedContextRegExp.source + innerQuasis.map(q => quotemeta(q.string) + options.wrappedContextRegExp.source).join(\"\");\n\n    // Example: `./context/pre${e}inner${e}inner2${e}post?query`\n    // context: \"./context\"\n    // prefix: \"./pre\"\n    // innerQuasis: [BEE(\"inner\"), BEE(\"inner2\")]\n    // (BEE = BasicEvaluatedExpression)\n    // postfix: \"post\"\n    // query: \"?query\"\n    // regExp: /^\\.\\/pre.*inner.*inner2.*post$/\n    const regExp = new RegExp(`^${quotemeta(prefix)}${innerRegExp}${quotemeta(postfix)}$`);\n    const dep = new Dep(Object.assign({\n      request: context + query,\n      recursive: options.wrappedContextRecursive,\n      regExp,\n      mode: \"sync\"\n    }, contextOptions), range, valueRange);\n    dep.loc = expr.loc;\n    const replaces = [];\n    param.parts.forEach((part, i) => {\n      if (i % 2 === 0) {\n        // Quasis or merged quasi\n        let range = part.range;\n        let value = part.string;\n        if (param.templateStringKind === \"cooked\") {\n          value = JSON.stringify(value);\n          value = value.slice(1, value.length - 1);\n        }\n        if (i === 0) {\n          // prefix\n          value = prefix;\n          range = [param.range[0], part.range[1]];\n          value = (param.templateStringKind === \"cooked\" ? \"`\" : \"String.raw`\") + value;\n        } else if (i === param.parts.length - 1) {\n          // postfix\n          value = postfix;\n          range = [part.range[0], param.range[1]];\n          value = value + \"`\";\n        } else if (part.expression && part.expression.type === \"TemplateElement\" && part.expression.value.raw === value) {\n          // Shortcut when it's a single quasi and doesn't need to be replaced\n          return;\n        }\n        replaces.push({\n          range,\n          value\n        });\n      } else {\n        // Expression\n        if (parser) {\n          parser.walkExpression(part.expression);\n        }\n      }\n    });\n    dep.replaces = replaces;\n    dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n    return dep;\n  } else if (param.isWrapped() && (param.prefix && param.prefix.isString() || param.postfix && param.postfix.isString())) {\n    let prefixRaw = param.prefix && param.prefix.isString() ? param.prefix.string : \"\";\n    let postfixRaw = param.postfix && param.postfix.isString() ? param.postfix.string : \"\";\n    const prefixRange = param.prefix && param.prefix.isString() ? param.prefix.range : null;\n    const postfixRange = param.postfix && param.postfix.isString() ? param.postfix.range : null;\n    const valueRange = param.range;\n    const {\n      context,\n      prefix\n    } = splitContextFromPrefix(prefixRaw);\n    const {\n      postfix,\n      query\n    } = splitQueryFromPostfix(postfixRaw);\n    const regExp = new RegExp(`^${quotemeta(prefix)}${options.wrappedContextRegExp.source}${quotemeta(postfix)}$`);\n    const dep = new Dep(Object.assign({\n      request: context + query,\n      recursive: options.wrappedContextRecursive,\n      regExp,\n      mode: \"sync\"\n    }, contextOptions), range, valueRange);\n    dep.loc = expr.loc;\n    const replaces = [];\n    if (prefixRange) {\n      replaces.push({\n        range: prefixRange,\n        value: JSON.stringify(prefix)\n      });\n    }\n    if (postfixRange) {\n      replaces.push({\n        range: postfixRange,\n        value: JSON.stringify(postfix)\n      });\n    }\n    dep.replaces = replaces;\n    dep.critical = options.wrappedContextCritical && \"a part of the request of a dependency is an expression\";\n    if (parser && param.wrappedInnerExpressions) {\n      for (const part of param.wrappedInnerExpressions) {\n        if (part.expression) parser.walkExpression(part.expression);\n      }\n    }\n    return dep;\n  } else {\n    const dep = new Dep(Object.assign({\n      request: options.exprContextRequest,\n      recursive: options.exprContextRecursive,\n      regExp: options.exprContextRegExp,\n      mode: \"sync\"\n    }, contextOptions), range, param.range);\n    dep.loc = expr.loc;\n    dep.critical = options.exprContextCritical && \"the request of a dependency is an expression\";\n    if (parser) {\n      parser.walkExpression(param.expression);\n    }\n    return dep;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}