{"ast":null,"code":"'use strict';\n\nconst pLimit = require('p-limit');\nclass EndError extends Error {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\n// The input can also be a promise, so we `Promise.resolve()` it\nconst testElement = (el, tester) => Promise.resolve(el).then(tester);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = el => Promise.all(el).then(val => val[1] === true && Promise.reject(new EndError(val[0])));\nmodule.exports = (iterable, tester, opts) => {\n  opts = Object.assign({\n    concurrency: Infinity,\n    preserveOrder: true\n  }, opts);\n  const limit = pLimit(opts.concurrency);\n\n  // Start all the promises concurrently with optional limit\n  const items = [...iterable].map(el => [el, limit(testElement, el, tester)]);\n\n  // Check the promises either serially or concurrently\n  const checkLimit = pLimit(opts.preserveOrder ? 1 : Infinity);\n  return Promise.all(items.map(el => checkLimit(finder, el))).then(() => {}).catch(err => err instanceof EndError ? err.value : Promise.reject(err));\n};","map":null,"metadata":{},"sourceType":"script"}