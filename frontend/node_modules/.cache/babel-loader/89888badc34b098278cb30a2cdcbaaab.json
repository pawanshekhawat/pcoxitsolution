{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\nconst acorn = require(\"acorn\");\nconst acornDynamicImport = require(\"acorn-dynamic-import\").default;\nconst {\n  Tapable,\n  SyncBailHook,\n  HookMap\n} = require(\"tapable\");\nconst util = require(\"util\");\nconst vm = require(\"vm\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst StackedSetMap = require(\"./util/StackedSetMap\");\nconst TrackingSet = require(\"./util/TrackingSet\");\nconst acornParser = acorn.Parser.extend(acornDynamicImport);\nconst joinRanges = (startRange, endRange) => {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\nconst defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: 2019,\n  sourceType: \"module\",\n  onComment: null\n};\n\n// regexp to match at lease one \"magic comment\"\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nconst EMPTY_ARRAY = [];\nconst EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\nclass Parser extends Tapable {\n  constructor(options, sourceType = \"auto\") {\n    super();\n    this.hooks = {\n      evaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateDefinedIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateCallExpressionMember: new HookMap(() => new SyncBailHook([\"expression\", \"param\"])),\n      statement: new SyncBailHook([\"statement\"]),\n      statementIf: new SyncBailHook([\"statement\"]),\n      label: new HookMap(() => new SyncBailHook([\"statement\"])),\n      import: new SyncBailHook([\"statement\", \"source\"]),\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n      export: new SyncBailHook([\"statement\"]),\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n      varDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      canRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n      rename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n      assigned: new HookMap(() => new SyncBailHook([\"expression\"])),\n      assign: new HookMap(() => new SyncBailHook([\"expression\"])),\n      typeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n      importCall: new SyncBailHook([\"expression\"]),\n      call: new HookMap(() => new SyncBailHook([\"expression\"])),\n      callAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n      new: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expression: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expressionAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n      program: new SyncBailHook([\"ast\", \"comments\"])\n    };\n    const HOOK_MAP_COMPAT_CONFIG = {\n      evaluateTypeof: /^evaluate typeof (.+)$/,\n      evaluateIdentifier: /^evaluate Identifier (.+)$/,\n      evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n      evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n      evaluate: /^evaluate (.+)$/,\n      label: /^label (.+)$/,\n      varDeclarationLet: /^var-let (.+)$/,\n      varDeclarationConst: /^var-const (.+)$/,\n      varDeclarationVar: /^var-var (.+)$/,\n      varDeclaration: /^var (.+)$/,\n      canRename: /^can-rename (.+)$/,\n      rename: /^rename (.+)$/,\n      typeof: /^typeof (.+)$/,\n      assigned: /^assigned (.+)$/,\n      assign: /^assign (.+)$/,\n      callAnyMember: /^call (.+)\\.\\*$/,\n      call: /^call (.+)$/,\n      new: /^new (.+)$/,\n      expressionConditionalOperator: /^expression \\?:$/,\n      expressionAnyMember: /^expression (.+)\\.\\*$/,\n      expression: /^expression (.+)$/\n    };\n    this._pluginCompat.tap(\"Parser\", options => {\n      for (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {\n        const regexp = HOOK_MAP_COMPAT_CONFIG[name];\n        const match = regexp.exec(options.name);\n        if (match) {\n          if (match[1]) {\n            this.hooks[name].tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn.bind(this));\n          } else {\n            this.hooks[name].tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(this));\n          }\n          return true;\n        }\n      }\n    });\n    this.options = options;\n    this.sourceType = sourceType;\n    this.scope = undefined;\n    this.state = undefined;\n    this.comments = undefined;\n    this.initializeEvaluating();\n  }\n  initializeEvaluating() {\n    this.hooks.evaluate.for(\"Literal\").tap(\"Parser\", expr => {\n      switch (typeof expr.value) {\n        case \"number\":\n          return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n        case \"string\":\n          return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n        case \"boolean\":\n          return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n      }\n      if (expr.value === null) {\n        return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n      }\n      if (expr.value instanceof RegExp) {\n        return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", expr => {\n      let left;\n      let leftAsBool;\n      let right;\n      if (expr.operator === \"&&\") {\n        left = this.evaluateExpression(expr.left);\n        leftAsBool = left && left.asBool();\n        if (leftAsBool === false) return left.setRange(expr.range);\n        if (leftAsBool !== true) return;\n        right = this.evaluateExpression(expr.right);\n        return right.setRange(expr.range);\n      } else if (expr.operator === \"||\") {\n        left = this.evaluateExpression(expr.left);\n        leftAsBool = left && left.asBool();\n        if (leftAsBool === true) return left.setRange(expr.range);\n        if (leftAsBool !== false) return;\n        right = this.evaluateExpression(expr.right);\n        return right.setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", expr => {\n      let left;\n      let right;\n      let res;\n      if (expr.operator === \"+\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n        if (left.isString()) {\n          if (right.isString()) {\n            res.setString(left.string + right.string);\n          } else if (right.isNumber()) {\n            res.setString(left.string + right.number);\n          } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n            // \"left\" + (\"prefix\" + inner + \"postfix\")\n            // => (\"leftprefix\" + inner + \"postfix\")\n            res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // \"left\" + ([null] + inner + \"postfix\")\n            // => (\"left\" + inner + \"postfix\")\n            res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n          } else {\n            // \"left\" + expr\n            // => (\"left\" + expr + \"\")\n            res.setWrapped(left, null, [right]);\n          }\n        } else if (left.isNumber()) {\n          if (right.isString()) {\n            res.setString(left.number + right.string);\n          } else if (right.isNumber()) {\n            res.setNumber(left.number + right.number);\n          } else {\n            return;\n          }\n        } else if (left.isWrapped()) {\n          if (left.postfix && left.postfix.isString() && right.isString()) {\n            // (\"prefix\" + inner + \"postfix\") + \"right\"\n            // => (\"prefix\" + inner + \"postfixright\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n            // (\"prefix\" + inner + \"postfix\") + 123\n            // => (\"prefix\" + inner + \"postfix123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (right.isString()) {\n            // (\"prefix\" + inner + [null]) + \"right\"\n            // => (\"prefix\" + inner + \"right\")\n            res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n          } else if (right.isNumber()) {\n            // (\"prefix\" + inner + [null]) + 123\n            // => (\"prefix\" + inner + \"123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n            // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n            res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n          } else {\n            // (\"prefix\" + inner + postfix) + expr\n            // => (\"prefix\" + inner + postfix + expr + [null])\n            res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n          }\n        } else {\n          if (right.isString()) {\n            // left + \"right\"\n            // => ([null] + left + \"right\")\n            res.setWrapped(null, right, [left]);\n          } else if (right.isWrapped()) {\n            // left + (prefix + inner + \"postfix\")\n            // => ([null] + left + prefix + inner + \"postfix\")\n            res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n          } else {\n            return;\n          }\n        }\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"-\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number - right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"*\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number * right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"/\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number / right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"**\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(Math.pow(left.number, right.number));\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"==\" || expr.operator === \"===\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n        res.setRange(expr.range);\n        if (left.isString() && right.isString()) {\n          return res.setBoolean(left.string === right.string);\n        } else if (left.isNumber() && right.isNumber()) {\n          return res.setBoolean(left.number === right.number);\n        } else if (left.isBoolean() && right.isBoolean()) {\n          return res.setBoolean(left.bool === right.bool);\n        }\n      } else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n        res.setRange(expr.range);\n        if (left.isString() && right.isString()) {\n          return res.setBoolean(left.string !== right.string);\n        } else if (left.isNumber() && right.isNumber()) {\n          return res.setBoolean(left.number !== right.number);\n        } else if (left.isBoolean() && right.isBoolean()) {\n          return res.setBoolean(left.bool !== right.bool);\n        }\n      } else if (expr.operator === \"&\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number & right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"|\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number | right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"^\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number ^ right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \">>>\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number >>> right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \">>\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number >> right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"<<\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number << right.number);\n        res.setRange(expr.range);\n        return res;\n      }\n    });\n    this.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", expr => {\n      if (expr.operator === \"typeof\") {\n        let res;\n        let name;\n        if (expr.argument.type === \"Identifier\") {\n          name = this.scope.renames.get(expr.argument.name) || expr.argument.name;\n          if (!this.scope.definitions.has(name)) {\n            const hook = this.hooks.evaluateTypeof.get(name);\n            if (hook !== undefined) {\n              res = hook.call(expr);\n              if (res !== undefined) return res;\n            }\n          }\n        }\n        if (expr.argument.type === \"MemberExpression\") {\n          const exprName = this.getNameForExpression(expr.argument);\n          if (exprName && exprName.free) {\n            const hook = this.hooks.evaluateTypeof.get(exprName.name);\n            if (hook !== undefined) {\n              res = hook.call(expr);\n              if (res !== undefined) return res;\n            }\n          }\n        }\n        if (expr.argument.type === \"FunctionExpression\") {\n          return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n        }\n        const arg = this.evaluateExpression(expr.argument);\n        if (arg.isString() || arg.isWrapped()) {\n          return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n        }\n        if (arg.isNumber()) {\n          return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n        }\n        if (arg.isBoolean()) {\n          return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n        }\n        if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n          return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n        }\n      } else if (expr.operator === \"!\") {\n        const argument = this.evaluateExpression(expr.argument);\n        if (!argument) return;\n        if (argument.isBoolean()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);\n        }\n        if (argument.isTruthy()) {\n          return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);\n        }\n        if (argument.isFalsy()) {\n          return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);\n        }\n        if (argument.isString()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);\n        }\n        if (argument.isNumber()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);\n        }\n      } else if (expr.operator === \"~\") {\n        const argument = this.evaluateExpression(expr.argument);\n        if (!argument) return;\n        if (!argument.isNumber()) return;\n        const res = new BasicEvaluatedExpression();\n        res.setNumber(~argument.number);\n        res.setRange(expr.range);\n        return res;\n      }\n    });\n    this.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", expr => {\n      return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", expr => {\n      const name = this.scope.renames.get(expr.name) || expr.name;\n      if (!this.scope.definitions.has(expr.name)) {\n        const hook = this.hooks.evaluateIdentifier.get(name);\n        if (hook !== undefined) {\n          const result = hook.call(expr);\n          if (result) return result;\n        }\n        return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n      } else {\n        const hook = this.hooks.evaluateDefinedIdentifier.get(name);\n        if (hook !== undefined) {\n          return hook.call(expr);\n        }\n      }\n    });\n    this.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", expr => {\n      const name = this.scope.renames.get(\"this\");\n      if (name) {\n        const hook = this.hooks.evaluateIdentifier.get(name);\n        if (hook !== undefined) {\n          const result = hook.call(expr);\n          if (result) return result;\n        }\n        return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", expression => {\n      let exprName = this.getNameForExpression(expression);\n      if (exprName) {\n        if (exprName.free) {\n          const hook = this.hooks.evaluateIdentifier.get(exprName.name);\n          if (hook !== undefined) {\n            const result = hook.call(expression);\n            if (result) return result;\n          }\n          return new BasicEvaluatedExpression().setIdentifier(exprName.name).setRange(expression.range);\n        } else {\n          const hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);\n          if (hook !== undefined) {\n            return hook.call(expression);\n          }\n        }\n      }\n    });\n    this.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", expr => {\n      if (expr.callee.type !== \"MemberExpression\") return;\n      if (expr.callee.property.type !== (expr.callee.computed ? \"Literal\" : \"Identifier\")) return;\n      const param = this.evaluateExpression(expr.callee.object);\n      if (!param) return;\n      const property = expr.callee.property.name || expr.callee.property.value;\n      const hook = this.hooks.evaluateCallExpressionMember.get(property);\n      if (hook !== undefined) {\n        return hook.call(expr, param);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 2) return;\n      let arg1 = this.evaluateExpression(expr.arguments[0]);\n      let arg2 = this.evaluateExpression(expr.arguments[1]);\n      if (!arg1.isString() && !arg1.isRegExp()) return;\n      arg1 = arg1.regExp || arg1.string;\n      if (!arg2.isString()) return;\n      arg2 = arg2.string;\n      return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);\n    });\n    [\"substr\", \"substring\"].forEach(fn => {\n      this.hooks.evaluateCallExpressionMember.for(fn).tap(\"Parser\", (expr, param) => {\n        if (!param.isString()) return;\n        let arg1;\n        let result,\n          str = param.string;\n        switch (expr.arguments.length) {\n          case 1:\n            arg1 = this.evaluateExpression(expr.arguments[0]);\n            if (!arg1.isNumber()) return;\n            result = str[fn](arg1.number);\n            break;\n          case 2:\n            {\n              arg1 = this.evaluateExpression(expr.arguments[0]);\n              const arg2 = this.evaluateExpression(expr.arguments[1]);\n              if (!arg1.isNumber()) return;\n              if (!arg2.isNumber()) return;\n              result = str[fn](arg1.number, arg2.number);\n              break;\n            }\n          default:\n            return;\n        }\n        return new BasicEvaluatedExpression().setString(result).setRange(expr.range);\n      });\n    });\n\n    /**\n     * @param {string} kind \"cooked\" | \"raw\"\n     * @param {TODO} templateLiteralExpr TemplateLiteral expr\n     * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n     */\n    const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n      const quasis = [];\n      const parts = [];\n      for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n        const quasiExpr = templateLiteralExpr.quasis[i];\n        const quasi = quasiExpr.value[kind];\n        if (i > 0) {\n          const prevExpr = parts[parts.length - 1];\n          const expr = this.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n          const exprAsString = expr.asString();\n          if (typeof exprAsString === \"string\") {\n            // We can merge quasi + expr + quasi when expr\n            // is a const string\n\n            prevExpr.setString(prevExpr.string + exprAsString + quasi);\n            prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n            // We unset the expression as it doesn't match to a single expression\n            prevExpr.setExpression(undefined);\n            continue;\n          }\n          parts.push(expr);\n        }\n        const part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);\n        quasis.push(part);\n        parts.push(part);\n      }\n      return {\n        quasis,\n        parts\n      };\n    };\n    this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", node => {\n      const {\n        quasis,\n        parts\n      } = getSimplifiedTemplateResult(\"cooked\", node);\n      if (parts.length === 1) {\n        return parts[0].setRange(node.range);\n      }\n      return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(node.range);\n    });\n    this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", node => {\n      if (this.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n      const {\n        quasis,\n        parts\n      } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n      if (parts.length === 1) {\n        return parts[0].setRange(node.range);\n      }\n      return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(node.range);\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString() && !param.isWrapped()) return;\n      let stringSuffix = null;\n      let hasUnknownParams = false;\n      for (let i = expr.arguments.length - 1; i >= 0; i--) {\n        const argExpr = this.evaluateExpression(expr.arguments[i]);\n        if (!argExpr.isString() && !argExpr.isNumber()) {\n          hasUnknownParams = true;\n          break;\n        }\n        const value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n        const newString = value + (stringSuffix ? stringSuffix.string : \"\");\n        const newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n        stringSuffix = new BasicEvaluatedExpression().setString(newString).setRange(newRange);\n      }\n      if (hasUnknownParams) {\n        const prefix = param.isString() ? param : param.prefix;\n        return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix).setRange(expr.range);\n      } else if (param.isWrapped()) {\n        const postfix = stringSuffix || param.postfix;\n        return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix).setRange(expr.range);\n      } else {\n        const newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n        return new BasicEvaluatedExpression().setString(newString).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 1) return;\n      let result;\n      const arg = this.evaluateExpression(expr.arguments[0]);\n      if (arg.isString()) {\n        result = param.string.split(arg.string);\n      } else if (arg.isRegExp()) {\n        result = param.string.split(arg.regExp);\n      } else {\n        return;\n      }\n      return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", expr => {\n      const condition = this.evaluateExpression(expr.test);\n      const conditionValue = condition.asBool();\n      let res;\n      if (conditionValue === undefined) {\n        const consequent = this.evaluateExpression(expr.consequent);\n        const alternate = this.evaluateExpression(expr.alternate);\n        if (!consequent || !alternate) return;\n        res = new BasicEvaluatedExpression();\n        if (consequent.isConditional()) {\n          res.setOptions(consequent.options);\n        } else {\n          res.setOptions([consequent]);\n        }\n        if (alternate.isConditional()) {\n          res.addOptions(alternate.options);\n        } else {\n          res.addOptions([alternate]);\n        }\n      } else {\n        res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n      }\n      res.setRange(expr.range);\n      return res;\n    });\n    this.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", expr => {\n      const items = expr.elements.map(element => {\n        return element !== null && this.evaluateExpression(element);\n      });\n      if (!items.every(Boolean)) return;\n      return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n    });\n  }\n  getRenameIdentifier(expr) {\n    const result = this.evaluateExpression(expr);\n    if (result && result.isIdentifier()) {\n      return result.identifier;\n    }\n  }\n  walkClass(classy) {\n    if (classy.superClass) this.walkExpression(classy.superClass);\n    if (classy.body && classy.body.type === \"ClassBody\") {\n      const wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n      for (const methodDefinition of classy.body.body) {\n        if (methodDefinition.type === \"MethodDefinition\") {\n          this.walkMethodDefinition(methodDefinition);\n        }\n      }\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }\n  walkMethodDefinition(methodDefinition) {\n    if (methodDefinition.computed && methodDefinition.key) {\n      this.walkExpression(methodDefinition.key);\n    }\n    if (methodDefinition.value) {\n      this.walkExpression(methodDefinition.value);\n    }\n  }\n\n  // Prewalking iterates the scope for variable declarations\n  prewalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.prewalkStatement(statement);\n    }\n  }\n\n  // Walking iterates the statements and expressions and processes them\n  walkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.walkStatement(statement);\n    }\n  }\n  prewalkStatement(statement) {\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.prewalkBlockStatement(statement);\n        break;\n      case \"ClassDeclaration\":\n        this.prewalkClassDeclaration(statement);\n        break;\n      case \"DoWhileStatement\":\n        this.prewalkDoWhileStatement(statement);\n        break;\n      case \"ExportAllDeclaration\":\n        this.prewalkExportAllDeclaration(statement);\n        break;\n      case \"ExportDefaultDeclaration\":\n        this.prewalkExportDefaultDeclaration(statement);\n        break;\n      case \"ExportNamedDeclaration\":\n        this.prewalkExportNamedDeclaration(statement);\n        break;\n      case \"ForInStatement\":\n        this.prewalkForInStatement(statement);\n        break;\n      case \"ForOfStatement\":\n        this.prewalkForOfStatement(statement);\n        break;\n      case \"ForStatement\":\n        this.prewalkForStatement(statement);\n        break;\n      case \"FunctionDeclaration\":\n        this.prewalkFunctionDeclaration(statement);\n        break;\n      case \"IfStatement\":\n        this.prewalkIfStatement(statement);\n        break;\n      case \"ImportDeclaration\":\n        this.prewalkImportDeclaration(statement);\n        break;\n      case \"LabeledStatement\":\n        this.prewalkLabeledStatement(statement);\n        break;\n      case \"SwitchStatement\":\n        this.prewalkSwitchStatement(statement);\n        break;\n      case \"TryStatement\":\n        this.prewalkTryStatement(statement);\n        break;\n      case \"VariableDeclaration\":\n        this.prewalkVariableDeclaration(statement);\n        break;\n      case \"WhileStatement\":\n        this.prewalkWhileStatement(statement);\n        break;\n      case \"WithStatement\":\n        this.prewalkWithStatement(statement);\n        break;\n    }\n  }\n  walkStatement(statement) {\n    if (this.hooks.statement.call(statement) !== undefined) return;\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.walkBlockStatement(statement);\n        break;\n      case \"ClassDeclaration\":\n        this.walkClassDeclaration(statement);\n        break;\n      case \"DoWhileStatement\":\n        this.walkDoWhileStatement(statement);\n        break;\n      case \"ExportDefaultDeclaration\":\n        this.walkExportDefaultDeclaration(statement);\n        break;\n      case \"ExportNamedDeclaration\":\n        this.walkExportNamedDeclaration(statement);\n        break;\n      case \"ExpressionStatement\":\n        this.walkExpressionStatement(statement);\n        break;\n      case \"ForInStatement\":\n        this.walkForInStatement(statement);\n        break;\n      case \"ForOfStatement\":\n        this.walkForOfStatement(statement);\n        break;\n      case \"ForStatement\":\n        this.walkForStatement(statement);\n        break;\n      case \"FunctionDeclaration\":\n        this.walkFunctionDeclaration(statement);\n        break;\n      case \"IfStatement\":\n        this.walkIfStatement(statement);\n        break;\n      case \"LabeledStatement\":\n        this.walkLabeledStatement(statement);\n        break;\n      case \"ReturnStatement\":\n        this.walkReturnStatement(statement);\n        break;\n      case \"SwitchStatement\":\n        this.walkSwitchStatement(statement);\n        break;\n      case \"ThrowStatement\":\n        this.walkThrowStatement(statement);\n        break;\n      case \"TryStatement\":\n        this.walkTryStatement(statement);\n        break;\n      case \"VariableDeclaration\":\n        this.walkVariableDeclaration(statement);\n        break;\n      case \"WhileStatement\":\n        this.walkWhileStatement(statement);\n        break;\n      case \"WithStatement\":\n        this.walkWithStatement(statement);\n        break;\n    }\n  }\n\n  // Real Statements\n  prewalkBlockStatement(statement) {\n    this.prewalkStatements(statement.body);\n  }\n  walkBlockStatement(statement) {\n    this.walkStatements(statement.body);\n  }\n  walkExpressionStatement(statement) {\n    this.walkExpression(statement.expression);\n  }\n  prewalkIfStatement(statement) {\n    this.prewalkStatement(statement.consequent);\n    if (statement.alternate) {\n      this.prewalkStatement(statement.alternate);\n    }\n  }\n  walkIfStatement(statement) {\n    const result = this.hooks.statementIf.call(statement);\n    if (result === undefined) {\n      this.walkExpression(statement.test);\n      this.walkStatement(statement.consequent);\n      if (statement.alternate) {\n        this.walkStatement(statement.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkStatement(statement.consequent);\n      } else if (statement.alternate) {\n        this.walkStatement(statement.alternate);\n      }\n    }\n  }\n  prewalkLabeledStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n  walkLabeledStatement(statement) {\n    const hook = this.hooks.label.get(statement.label.name);\n    if (hook !== undefined) {\n      const result = hook.call(statement);\n      if (result === true) return;\n    }\n    this.walkStatement(statement.body);\n  }\n  prewalkWithStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n  walkWithStatement(statement) {\n    this.walkExpression(statement.object);\n    this.walkStatement(statement.body);\n  }\n  prewalkSwitchStatement(statement) {\n    this.prewalkSwitchCases(statement.cases);\n  }\n  walkSwitchStatement(statement) {\n    this.walkExpression(statement.discriminant);\n    this.walkSwitchCases(statement.cases);\n  }\n  walkTerminatingStatement(statement) {\n    if (statement.argument) this.walkExpression(statement.argument);\n  }\n  walkReturnStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n  walkThrowStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n  prewalkTryStatement(statement) {\n    this.prewalkStatement(statement.block);\n  }\n  walkTryStatement(statement) {\n    if (this.scope.inTry) {\n      this.walkStatement(statement.block);\n    } else {\n      this.scope.inTry = true;\n      this.walkStatement(statement.block);\n      this.scope.inTry = false;\n    }\n    if (statement.handler) this.walkCatchClause(statement.handler);\n    if (statement.finalizer) this.walkStatement(statement.finalizer);\n  }\n  prewalkWhileStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n  walkWhileStatement(statement) {\n    this.walkExpression(statement.test);\n    this.walkStatement(statement.body);\n  }\n  prewalkDoWhileStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n  walkDoWhileStatement(statement) {\n    this.walkStatement(statement.body);\n    this.walkExpression(statement.test);\n  }\n  prewalkForStatement(statement) {\n    if (statement.init) {\n      if (statement.init.type === \"VariableDeclaration\") {\n        this.prewalkStatement(statement.init);\n      }\n    }\n    this.prewalkStatement(statement.body);\n  }\n  walkForStatement(statement) {\n    if (statement.init) {\n      if (statement.init.type === \"VariableDeclaration\") {\n        this.walkStatement(statement.init);\n      } else {\n        this.walkExpression(statement.init);\n      }\n    }\n    if (statement.test) {\n      this.walkExpression(statement.test);\n    }\n    if (statement.update) {\n      this.walkExpression(statement.update);\n    }\n    this.walkStatement(statement.body);\n  }\n  prewalkForInStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.prewalkVariableDeclaration(statement.left);\n    }\n    this.prewalkStatement(statement.body);\n  }\n  walkForInStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.walkVariableDeclaration(statement.left);\n    } else {\n      this.walkPattern(statement.left);\n    }\n    this.walkExpression(statement.right);\n    this.walkStatement(statement.body);\n  }\n  prewalkForOfStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.prewalkVariableDeclaration(statement.left);\n    }\n    this.prewalkStatement(statement.body);\n  }\n  walkForOfStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.walkVariableDeclaration(statement.left);\n    } else {\n      this.walkPattern(statement.left);\n    }\n    this.walkExpression(statement.right);\n    this.walkStatement(statement.body);\n  }\n\n  // Declarations\n  prewalkFunctionDeclaration(statement) {\n    if (statement.id) {\n      this.scope.renames.set(statement.id.name, null);\n      this.scope.definitions.add(statement.id.name);\n    }\n  }\n  walkFunctionDeclaration(statement) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    this.inScope(statement.params, () => {\n      for (const param of statement.params) {\n        this.walkPattern(param);\n      }\n      if (statement.body.type === \"BlockStatement\") {\n        this.detectStrictMode(statement.body.body);\n        this.prewalkStatement(statement.body);\n        this.walkStatement(statement.body);\n      } else {\n        this.walkExpression(statement.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n  prewalkImportDeclaration(statement) {\n    const source = statement.source.value;\n    this.hooks.import.call(statement, source);\n    for (const specifier of statement.specifiers) {\n      const name = specifier.local.name;\n      this.scope.renames.set(name, null);\n      this.scope.definitions.add(name);\n      switch (specifier.type) {\n        case \"ImportDefaultSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, \"default\", name);\n          break;\n        case \"ImportSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name);\n          break;\n        case \"ImportNamespaceSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, null, name);\n          break;\n      }\n    }\n  }\n  prewalkExportNamedDeclaration(statement) {\n    let source;\n    if (statement.source) {\n      source = statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n    } else {\n      this.hooks.export.call(statement);\n    }\n    if (statement.declaration) {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        const originalDefinitions = this.scope.definitions;\n        const tracker = new TrackingSet(this.scope.definitions);\n        this.scope.definitions = tracker;\n        this.prewalkStatement(statement.declaration);\n        const newDefs = Array.from(tracker.getAddedItems());\n        this.scope.definitions = originalDefinitions;\n        for (let index = newDefs.length - 1; index >= 0; index--) {\n          const def = newDefs[index];\n          this.hooks.exportSpecifier.call(statement, def, def, index);\n        }\n      }\n    }\n    if (statement.specifiers) {\n      for (let specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n        const specifier = statement.specifiers[specifierIndex];\n        switch (specifier.type) {\n          case \"ExportSpecifier\":\n            {\n              const name = specifier.exported.name;\n              if (source) {\n                this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n              } else {\n                this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n              }\n              break;\n            }\n        }\n      }\n    }\n  }\n  walkExportNamedDeclaration(statement) {\n    if (statement.declaration) {\n      this.walkStatement(statement.declaration);\n    }\n  }\n  prewalkExportDefaultDeclaration(statement) {\n    if (statement.declaration.id) {\n      const originalDefinitions = this.scope.definitions;\n      const tracker = new TrackingSet(this.scope.definitions);\n      this.scope.definitions = tracker;\n      this.prewalkStatement(statement.declaration);\n      const newDefs = Array.from(tracker.getAddedItems());\n      this.scope.definitions = originalDefinitions;\n      for (let index = 0, len = newDefs.length; index < len; index++) {\n        const def = newDefs[index];\n        this.hooks.exportSpecifier.call(statement, def, \"default\");\n      }\n    }\n  }\n  walkExportDefaultDeclaration(statement) {\n    this.hooks.export.call(statement);\n    if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        this.walkStatement(statement.declaration);\n      }\n    } else {\n      // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n      // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n      // These nodes must be treated as expressions.\n      if (statement.declaration.type === \"FunctionDeclaration\") {\n        this.walkFunctionDeclaration(statement.declaration);\n      } else if (statement.declaration.type === \"ClassDeclaration\") {\n        this.walkClassDeclaration(statement.declaration);\n      } else {\n        this.walkExpression(statement.declaration);\n      }\n      if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n        this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\");\n      }\n    }\n  }\n  prewalkExportAllDeclaration(statement) {\n    const source = statement.source.value;\n    this.hooks.exportImport.call(statement, source);\n    this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n  }\n  prewalkVariableDeclaration(statement) {\n    const hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : statement.kind === \"let\" ? this.hooks.varDeclarationLet : this.hooks.varDeclarationVar;\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            this.enterPattern(declarator.id, (name, decl) => {\n              let hook = hookMap.get(name);\n              if (hook === undefined || !hook.call(decl)) {\n                hook = this.hooks.varDeclaration.get(name);\n                if (hook === undefined || !hook.call(decl)) {\n                  this.scope.renames.set(name, null);\n                  this.scope.definitions.add(name);\n                }\n              }\n            });\n            break;\n          }\n      }\n    }\n  }\n  walkVariableDeclaration(statement) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            const renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n            if (renameIdentifier && declarator.id.type === \"Identifier\") {\n              const hook = this.hooks.canRename.get(renameIdentifier);\n              if (hook !== undefined && hook.call(declarator.init)) {\n                // renaming with \"var a = b;\"\n                const hook = this.hooks.rename.get(renameIdentifier);\n                if (hook === undefined || !hook.call(declarator.init)) {\n                  this.scope.renames.set(declarator.id.name, this.scope.renames.get(renameIdentifier) || renameIdentifier);\n                  this.scope.definitions.delete(declarator.id.name);\n                }\n                break;\n              }\n            }\n            this.walkPattern(declarator.id);\n            if (declarator.init) this.walkExpression(declarator.init);\n            break;\n          }\n      }\n    }\n  }\n  prewalkClassDeclaration(statement) {\n    if (statement.id) {\n      this.scope.renames.set(statement.id.name, null);\n      this.scope.definitions.add(statement.id.name);\n    }\n  }\n  walkClassDeclaration(statement) {\n    this.walkClass(statement);\n  }\n  prewalkSwitchCases(switchCases) {\n    for (let index = 0, len = switchCases.length; index < len; index++) {\n      const switchCase = switchCases[index];\n      this.prewalkStatements(switchCase.consequent);\n    }\n  }\n  walkSwitchCases(switchCases) {\n    for (let index = 0, len = switchCases.length; index < len; index++) {\n      const switchCase = switchCases[index];\n      if (switchCase.test) {\n        this.walkExpression(switchCase.test);\n      }\n      this.walkStatements(switchCase.consequent);\n    }\n  }\n  walkCatchClause(catchClause) {\n    // Error binding is optional in catch clause since ECMAScript 2019\n    const errorBinding = catchClause.param === null ? EMPTY_ARRAY : [catchClause.param];\n    this.inScope(errorBinding, () => {\n      this.prewalkStatement(catchClause.body);\n      this.walkStatement(catchClause.body);\n    });\n  }\n  walkPattern(pattern) {\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.walkArrayPattern(pattern);\n        break;\n      case \"AssignmentPattern\":\n        this.walkAssignmentPattern(pattern);\n        break;\n      case \"MemberExpression\":\n        this.walkMemberExpression(pattern);\n        break;\n      case \"ObjectPattern\":\n        this.walkObjectPattern(pattern);\n        break;\n      case \"RestElement\":\n        this.walkRestElement(pattern);\n        break;\n    }\n  }\n  walkAssignmentPattern(pattern) {\n    this.walkExpression(pattern.right);\n    this.walkPattern(pattern.left);\n  }\n  walkObjectPattern(pattern) {\n    for (let i = 0, len = pattern.properties.length; i < len; i++) {\n      const prop = pattern.properties[i];\n      if (prop) {\n        if (prop.computed) this.walkExpression(prop.key);\n        if (prop.value) this.walkPattern(prop.value);\n      }\n    }\n  }\n  walkArrayPattern(pattern) {\n    for (let i = 0, len = pattern.elements.length; i < len; i++) {\n      const element = pattern.elements[i];\n      if (element) this.walkPattern(element);\n    }\n  }\n  walkRestElement(pattern) {\n    this.walkPattern(pattern.argument);\n  }\n  walkExpressions(expressions) {\n    for (const expression of expressions) {\n      if (expression) {\n        this.walkExpression(expression);\n      }\n    }\n  }\n  walkExpression(expression) {\n    switch (expression.type) {\n      case \"ArrayExpression\":\n        this.walkArrayExpression(expression);\n        break;\n      case \"ArrowFunctionExpression\":\n        this.walkArrowFunctionExpression(expression);\n        break;\n      case \"AssignmentExpression\":\n        this.walkAssignmentExpression(expression);\n        break;\n      case \"AwaitExpression\":\n        this.walkAwaitExpression(expression);\n        break;\n      case \"BinaryExpression\":\n        this.walkBinaryExpression(expression);\n        break;\n      case \"CallExpression\":\n        this.walkCallExpression(expression);\n        break;\n      case \"ClassExpression\":\n        this.walkClassExpression(expression);\n        break;\n      case \"ConditionalExpression\":\n        this.walkConditionalExpression(expression);\n        break;\n      case \"FunctionExpression\":\n        this.walkFunctionExpression(expression);\n        break;\n      case \"Identifier\":\n        this.walkIdentifier(expression);\n        break;\n      case \"LogicalExpression\":\n        this.walkLogicalExpression(expression);\n        break;\n      case \"MemberExpression\":\n        this.walkMemberExpression(expression);\n        break;\n      case \"NewExpression\":\n        this.walkNewExpression(expression);\n        break;\n      case \"ObjectExpression\":\n        this.walkObjectExpression(expression);\n        break;\n      case \"SequenceExpression\":\n        this.walkSequenceExpression(expression);\n        break;\n      case \"SpreadElement\":\n        this.walkSpreadElement(expression);\n        break;\n      case \"TaggedTemplateExpression\":\n        this.walkTaggedTemplateExpression(expression);\n        break;\n      case \"TemplateLiteral\":\n        this.walkTemplateLiteral(expression);\n        break;\n      case \"ThisExpression\":\n        this.walkThisExpression(expression);\n        break;\n      case \"UnaryExpression\":\n        this.walkUnaryExpression(expression);\n        break;\n      case \"UpdateExpression\":\n        this.walkUpdateExpression(expression);\n        break;\n      case \"YieldExpression\":\n        this.walkYieldExpression(expression);\n        break;\n    }\n  }\n  walkAwaitExpression(expression) {\n    this.walkExpression(expression.argument);\n  }\n  walkArrayExpression(expression) {\n    if (expression.elements) {\n      this.walkExpressions(expression.elements);\n    }\n  }\n  walkSpreadElement(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n  walkObjectExpression(expression) {\n    for (let propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n      const prop = expression.properties[propIndex];\n      if (prop.type === \"SpreadElement\") {\n        this.walkExpression(prop.argument);\n        continue;\n      }\n      if (prop.computed) {\n        this.walkExpression(prop.key);\n      }\n      if (prop.shorthand) {\n        this.scope.inShorthand = true;\n      }\n      this.walkExpression(prop.value);\n      if (prop.shorthand) {\n        this.scope.inShorthand = false;\n      }\n    }\n  }\n  walkFunctionExpression(expression) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    this.inScope(expression.params, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectStrictMode(expression.body.body);\n        this.prewalkStatement(expression.body);\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n  walkArrowFunctionExpression(expression) {\n    this.inScope(expression.params, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectStrictMode(expression.body.body);\n        this.prewalkStatement(expression.body);\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n  }\n  walkSequenceExpression(expression) {\n    if (expression.expressions) this.walkExpressions(expression.expressions);\n  }\n  walkUpdateExpression(expression) {\n    this.walkExpression(expression.argument);\n  }\n  walkUnaryExpression(expression) {\n    if (expression.operator === \"typeof\") {\n      const exprName = this.getNameForExpression(expression.argument);\n      if (exprName && exprName.free) {\n        const hook = this.hooks.typeof.get(exprName.name);\n        if (hook !== undefined) {\n          const result = hook.call(expression);\n          if (result === true) return;\n        }\n      }\n    }\n    this.walkExpression(expression.argument);\n  }\n  walkLeftRightExpression(expression) {\n    this.walkExpression(expression.left);\n    this.walkExpression(expression.right);\n  }\n  walkBinaryExpression(expression) {\n    this.walkLeftRightExpression(expression);\n  }\n  walkLogicalExpression(expression) {\n    const result = this.hooks.expressionLogicalOperator.call(expression);\n    if (result === undefined) {\n      this.walkLeftRightExpression(expression);\n    } else {\n      if (result) {\n        this.walkExpression(expression.right);\n      }\n    }\n  }\n  walkAssignmentExpression(expression) {\n    const renameIdentifier = this.getRenameIdentifier(expression.right);\n    if (expression.left.type === \"Identifier\" && renameIdentifier) {\n      const hook = this.hooks.canRename.get(renameIdentifier);\n      if (hook !== undefined && hook.call(expression.right)) {\n        // renaming \"a = b;\"\n        const hook = this.hooks.rename.get(renameIdentifier);\n        if (hook === undefined || !hook.call(expression.right)) {\n          this.scope.renames.set(expression.left.name, renameIdentifier);\n          this.scope.definitions.delete(expression.left.name);\n        }\n        return;\n      }\n    }\n    if (expression.left.type === \"Identifier\") {\n      const assignedHook = this.hooks.assigned.get(expression.left.name);\n      if (assignedHook === undefined || !assignedHook.call(expression)) {\n        this.walkExpression(expression.right);\n      }\n      this.scope.renames.set(expression.left.name, null);\n      const assignHook = this.hooks.assign.get(expression.left.name);\n      if (assignHook === undefined || !assignHook.call(expression)) {\n        this.walkExpression(expression.left);\n      }\n      return;\n    }\n    this.walkExpression(expression.right);\n    this.walkPattern(expression.left);\n    this.enterPattern(expression.left, (name, decl) => {\n      this.scope.renames.set(name, null);\n    });\n  }\n  walkConditionalExpression(expression) {\n    const result = this.hooks.expressionConditionalOperator.call(expression);\n    if (result === undefined) {\n      this.walkExpression(expression.test);\n      this.walkExpression(expression.consequent);\n      if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkExpression(expression.consequent);\n      } else if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    }\n  }\n  walkNewExpression(expression) {\n    const callee = this.evaluateExpression(expression.callee);\n    if (callee.isIdentifier()) {\n      const hook = this.hooks.new.get(callee.identifier);\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n        if (result === true) {\n          return;\n        }\n      }\n    }\n    this.walkExpression(expression.callee);\n    if (expression.arguments) {\n      this.walkExpressions(expression.arguments);\n    }\n  }\n  walkYieldExpression(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n  walkTemplateLiteral(expression) {\n    if (expression.expressions) {\n      this.walkExpressions(expression.expressions);\n    }\n  }\n  walkTaggedTemplateExpression(expression) {\n    if (expression.tag) {\n      this.walkExpression(expression.tag);\n    }\n    if (expression.quasi && expression.quasi.expressions) {\n      this.walkExpressions(expression.quasi.expressions);\n    }\n  }\n  walkClassExpression(expression) {\n    this.walkClass(expression);\n  }\n  _walkIIFE(functionExpression, options, currentThis) {\n    const renameArgOrThis = argOrThis => {\n      const renameIdentifier = this.getRenameIdentifier(argOrThis);\n      if (renameIdentifier) {\n        const hook = this.hooks.canRename.get(renameIdentifier);\n        if (hook !== undefined && hook.call(argOrThis)) {\n          const hook = this.hooks.rename.get(renameIdentifier);\n          if (hook === undefined || !hook.call(argOrThis)) {\n            return renameIdentifier;\n          }\n        }\n      }\n      this.walkExpression(argOrThis);\n    };\n    const params = functionExpression.params;\n    const renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n    const args = options.map(renameArgOrThis);\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    this.inScope(params.filter((identifier, idx) => !args[idx]), () => {\n      if (renameThis) {\n        this.scope.renames.set(\"this\", renameThis);\n      }\n      for (let i = 0; i < args.length; i++) {\n        const param = args[i];\n        if (!param) continue;\n        if (!params[i] || params[i].type !== \"Identifier\") continue;\n        this.scope.renames.set(params[i].name, param);\n      }\n      if (functionExpression.body.type === \"BlockStatement\") {\n        this.prewalkStatement(functionExpression.body);\n        this.walkStatement(functionExpression.body);\n      } else {\n        this.walkExpression(functionExpression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n  walkCallExpression(expression) {\n    if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type === \"FunctionExpression\" && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0) {\n      // (function() { }.call/bind(?, ))\n      this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n    } else if (expression.callee.type === \"FunctionExpression\") {\n      // (function() { }())\n      this._walkIIFE(expression.callee, expression.arguments, null);\n    } else if (expression.callee.type === \"Import\") {\n      let result = this.hooks.importCall.call(expression);\n      if (result === true) return;\n      if (expression.arguments) this.walkExpressions(expression.arguments);\n    } else {\n      const callee = this.evaluateExpression(expression.callee);\n      if (callee.isIdentifier()) {\n        const callHook = this.hooks.call.get(callee.identifier);\n        if (callHook !== undefined) {\n          let result = callHook.call(expression);\n          if (result === true) return;\n        }\n        let identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n        if (identifier !== callee.identifier) {\n          const callAnyHook = this.hooks.callAnyMember.get(identifier);\n          if (callAnyHook !== undefined) {\n            let result = callAnyHook.call(expression);\n            if (result === true) return;\n          }\n        }\n      }\n      if (expression.callee) this.walkExpression(expression.callee);\n      if (expression.arguments) this.walkExpressions(expression.arguments);\n    }\n  }\n  walkMemberExpression(expression) {\n    const exprName = this.getNameForExpression(expression);\n    if (exprName && exprName.free) {\n      const expressionHook = this.hooks.expression.get(exprName.name);\n      if (expressionHook !== undefined) {\n        const result = expressionHook.call(expression);\n        if (result === true) return;\n      }\n      const expressionAnyMemberHook = this.hooks.expressionAnyMember.get(exprName.nameGeneral);\n      if (expressionAnyMemberHook !== undefined) {\n        const result = expressionAnyMemberHook.call(expression);\n        if (result === true) return;\n      }\n    }\n    this.walkExpression(expression.object);\n    if (expression.computed === true) this.walkExpression(expression.property);\n  }\n  walkThisExpression(expression) {\n    const expressionHook = this.hooks.expression.get(\"this\");\n    if (expressionHook !== undefined) {\n      expressionHook.call(expression);\n    }\n  }\n  walkIdentifier(expression) {\n    if (!this.scope.definitions.has(expression.name)) {\n      const hook = this.hooks.expression.get(this.scope.renames.get(expression.name) || expression.name);\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n        if (result === true) return;\n      }\n    }\n  }\n  inScope(params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      definitions: oldScope.definitions.createChild(),\n      renames: oldScope.renames.createChild()\n    };\n    this.scope.renames.set(\"this\", null);\n    for (const param of params) {\n      if (typeof param !== \"string\") {\n        this.enterPattern(param, param => {\n          this.scope.renames.set(param, null);\n          this.scope.definitions.add(param);\n        });\n      } else if (param) {\n        this.scope.renames.set(param, null);\n        this.scope.definitions.add(param);\n      }\n    }\n    fn();\n    this.scope = oldScope;\n  }\n  detectStrictMode(statements) {\n    const isStrict = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\" && statements[0].expression.value === \"use strict\";\n    if (isStrict) {\n      this.scope.isStrict = true;\n    }\n  }\n  enterPattern(pattern, onIdent) {\n    if (!pattern) return;\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.enterArrayPattern(pattern, onIdent);\n        break;\n      case \"AssignmentPattern\":\n        this.enterAssignmentPattern(pattern, onIdent);\n        break;\n      case \"Identifier\":\n        this.enterIdentifier(pattern, onIdent);\n        break;\n      case \"ObjectPattern\":\n        this.enterObjectPattern(pattern, onIdent);\n        break;\n      case \"RestElement\":\n        this.enterRestElement(pattern, onIdent);\n        break;\n    }\n  }\n  enterIdentifier(pattern, onIdent) {\n    onIdent(pattern.name, pattern);\n  }\n  enterObjectPattern(pattern, onIdent) {\n    for (let propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n      const prop = pattern.properties[propIndex];\n      this.enterPattern(prop.value, onIdent);\n    }\n  }\n  enterArrayPattern(pattern, onIdent) {\n    for (let elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n      const element = pattern.elements[elementIndex];\n      this.enterPattern(element, onIdent);\n    }\n  }\n  enterRestElement(pattern, onIdent) {\n    this.enterPattern(pattern.argument, onIdent);\n  }\n  enterAssignmentPattern(pattern, onIdent) {\n    this.enterPattern(pattern.left, onIdent);\n  }\n  evaluateExpression(expression) {\n    try {\n      const hook = this.hooks.evaluate.get(expression.type);\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n        if (result !== undefined) {\n          if (result) {\n            result.setExpression(expression);\n          }\n          return result;\n        }\n      }\n    } catch (e) {\n      console.warn(e);\n      // ignore error\n    }\n\n    return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);\n  }\n  parseString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          return this.parseString(expression.left) + this.parseString(expression.right);\n        }\n        break;\n      case \"Literal\":\n        return expression.value + \"\";\n    }\n    throw new Error(expression.type + \" is not supported as parameter for require\");\n  }\n  parseCalculatedString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          const left = this.parseCalculatedString(expression.left);\n          const right = this.parseCalculatedString(expression.right);\n          if (left.code) {\n            return {\n              range: left.range,\n              value: left.value,\n              code: true,\n              conditional: false\n            };\n          } else if (right.code) {\n            return {\n              range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n              value: left.value + right.value,\n              code: true,\n              conditional: false\n            };\n          } else {\n            return {\n              range: [left.range[0], right.range[1]],\n              value: left.value + right.value,\n              code: false,\n              conditional: false\n            };\n          }\n        }\n        break;\n      case \"ConditionalExpression\":\n        {\n          const consequent = this.parseCalculatedString(expression.consequent);\n          const alternate = this.parseCalculatedString(expression.alternate);\n          const items = [];\n          if (consequent.conditional) {\n            items.push(...consequent.conditional);\n          } else if (!consequent.code) {\n            items.push(consequent);\n          } else {\n            break;\n          }\n          if (alternate.conditional) {\n            items.push(...alternate.conditional);\n          } else if (!alternate.code) {\n            items.push(alternate);\n          } else {\n            break;\n          }\n          return {\n            range: undefined,\n            value: \"\",\n            code: true,\n            conditional: items\n          };\n        }\n      case \"Literal\":\n        return {\n          range: expression.range,\n          value: expression.value + \"\",\n          code: false,\n          conditional: false\n        };\n    }\n    return {\n      range: undefined,\n      value: \"\",\n      code: true,\n      conditional: false\n    };\n  }\n  parse(source, initialState) {\n    let ast;\n    let comments;\n    if (typeof source === \"object\" && source !== null) {\n      ast = source;\n      comments = source.comments;\n    } else {\n      comments = [];\n      ast = Parser.parse(source, {\n        sourceType: this.sourceType,\n        onComment: comments\n      });\n    }\n    const oldScope = this.scope;\n    const oldState = this.state;\n    const oldComments = this.comments;\n    this.scope = {\n      topLevelScope: true,\n      inTry: false,\n      inShorthand: false,\n      isStrict: false,\n      definitions: new StackedSetMap(),\n      renames: new StackedSetMap()\n    };\n    const state = this.state = initialState || {};\n    this.comments = comments;\n    if (this.hooks.program.call(ast, comments) === undefined) {\n      this.detectStrictMode(ast.body);\n      this.prewalkStatements(ast.body);\n      this.walkStatements(ast.body);\n    }\n    this.scope = oldScope;\n    this.state = oldState;\n    this.comments = oldComments;\n    return state;\n  }\n  evaluate(source) {\n    const ast = Parser.parse(\"(\" + source + \")\", {\n      sourceType: this.sourceType,\n      locations: false\n    });\n    // TODO(https://github.com/acornjs/acorn/issues/741)\n    // @ts-ignore\n    if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n      throw new Error(\"evaluate: Source is not a expression\");\n    }\n    // TODO(https://github.com/acornjs/acorn/issues/741)\n    // @ts-ignore\n    return this.evaluateExpression(ast.body[0].expression);\n  }\n  getComments(range) {\n    return this.comments.filter(comment => comment.range[0] >= range[0] && comment.range[1] <= range[1]);\n  }\n  parseCommentOptions(range) {\n    const comments = this.getComments(range);\n    if (comments.length === 0) {\n      return EMPTY_COMMENT_OPTIONS;\n    }\n    let options = {};\n    let errors = [];\n    for (const comment of comments) {\n      const {\n        value\n      } = comment;\n      if (value && webpackCommentRegExp.test(value)) {\n        // try compile only if webpack options comment is present\n        try {\n          const val = vm.runInNewContext(`(function(){return {${value}};})()`);\n          Object.assign(options, val);\n        } catch (e) {\n          e.comment = comment;\n          errors.push(e);\n        }\n      }\n    }\n    return {\n      options,\n      errors\n    };\n  }\n  getNameForExpression(expression) {\n    let expr = expression;\n    const exprName = [];\n    while (expr.type === \"MemberExpression\" && expr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")) {\n      exprName.push(expr.computed ? expr.property.value : expr.property.name);\n      expr = expr.object;\n    }\n    let free;\n    if (expr.type === \"Identifier\") {\n      free = !this.scope.definitions.has(expr.name);\n      exprName.push(this.scope.renames.get(expr.name) || expr.name);\n    } else if (expr.type === \"ThisExpression\" && this.scope.renames.get(\"this\")) {\n      free = true;\n      exprName.push(this.scope.renames.get(\"this\"));\n    } else if (expr.type === \"ThisExpression\") {\n      free = this.scope.topLevelScope;\n      exprName.push(\"this\");\n    } else {\n      return null;\n    }\n    let prefix = \"\";\n    for (let i = exprName.length - 1; i >= 2; i--) {\n      prefix += exprName[i] + \".\";\n    }\n    if (exprName.length > 1) {\n      prefix += exprName[1];\n    }\n    const name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n    const nameGeneral = prefix;\n    return {\n      name,\n      nameGeneral,\n      free\n    };\n  }\n  static parse(code, options) {\n    const type = options ? options.sourceType : \"module\";\n    const parserOptions = Object.assign(Object.create(null), defaultParserOptions, options);\n    if (type === \"auto\") {\n      parserOptions.sourceType = \"module\";\n    }\n    let ast;\n    let error;\n    let threw = false;\n    try {\n      ast = acornParser.parse(code, parserOptions);\n    } catch (e) {\n      error = e;\n      threw = true;\n    }\n    if (threw && type === \"auto\") {\n      parserOptions.sourceType = \"script\";\n      if (Array.isArray(parserOptions.onComment)) {\n        parserOptions.onComment.length = 0;\n      }\n      try {\n        ast = acornParser.parse(code, parserOptions);\n        threw = false;\n      } catch (e) {\n        threw = true;\n      }\n    }\n    if (threw) {\n      throw error;\n    }\n    return ast;\n  }\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} range Range\n   * @returns {void}\n   * @this {Parser}\n   */\n  function (range) {\n    return this.parseCommentOptions(range).options;\n  }, \"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\")\n});\nmodule.exports = Parser;","map":null,"metadata":{},"sourceType":"script"}