{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  ConcatSource,\n  OriginalSource,\n  PrefixSource,\n  RawSource\n} = require(\"webpack-sources\");\nconst {\n  Tapable,\n  SyncWaterfallHook,\n  SyncHook,\n  SyncBailHook\n} = require(\"tapable\");\nconst Template = require(\"./Template\");\n\n/** @typedef {import(\"webpack-sources\").ConcatSource} ConcatSource */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./ModuleTemplate\")} ModuleTemplate */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Module\")} Module} */\n/** @typedef {import(\"./util/createHash\").Hash} Hash} */\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate} */\n\n/**\n * @typedef {Object} RenderManifestOptions\n * @property {Chunk} chunk the chunk used to render\n * @property {string} hash\n * @property {string} fullHash\n * @property {TODO} outputOptions\n * @property {{javascript: ModuleTemplate, webassembly: ModuleTemplate}} moduleTemplates\n * @property {Map<TODO, TODO>} dependencyTemplates\n */\n\n// require function shortcuts:\n// __webpack_require__.s = the module id of the entry point\n// __webpack_require__.c = the module cache\n// __webpack_require__.m = the module functions\n// __webpack_require__.p = the bundle public path\n// __webpack_require__.i = the identity function used for harmony imports\n// __webpack_require__.e = the chunk ensure function\n// __webpack_require__.d = the exported property define getter function\n// __webpack_require__.o = Object.prototype.hasOwnProperty.call\n// __webpack_require__.r = define compatibility on export\n// __webpack_require__.t = create a fake namespace object\n// __webpack_require__.n = compatibility get default export\n// __webpack_require__.h = the webpack hash\n// __webpack_require__.w = an object containing all installed WebAssembly.Instance export objects keyed by module id\n// __webpack_require__.oe = the uncaught error handler for the webpack runtime\n// __webpack_require__.nc = the script nonce\n\nmodule.exports = class MainTemplate extends Tapable {\n  /**\n   *\n   * @param {TODO=} outputOptions output options for the MainTemplate\n   */\n  constructor(outputOptions) {\n    super();\n    /** @type {TODO?} */\n    this.outputOptions = outputOptions || {};\n    this.hooks = {\n      /** @type {SyncWaterfallHook<TODO[], RenderManifestOptions>} */\n      renderManifest: new SyncWaterfallHook([\"result\", \"options\"]),\n      modules: new SyncWaterfallHook([\"modules\", \"chunk\", \"hash\", \"moduleTemplate\", \"dependencyTemplates\"]),\n      moduleObj: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleIdExpression\"]),\n      requireEnsure: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"chunkIdExpression\"]),\n      bootstrap: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleTemplate\", \"dependencyTemplates\"]),\n      localVars: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      require: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      requireExtensions: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      /** @type {SyncWaterfallHook<string, Chunk, string>} */\n      beforeStartup: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      /** @type {SyncWaterfallHook<string, Chunk, string>} */\n      startup: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      render: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleTemplate\", \"dependencyTemplates\"]),\n      renderWithEntry: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"]),\n      moduleRequire: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleIdExpression\"]),\n      addModule: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\", \"moduleIdExpression\", \"moduleExpression\"]),\n      currentHash: new SyncWaterfallHook([\"source\", \"requestedLength\"]),\n      assetPath: new SyncWaterfallHook([\"path\", \"options\"]),\n      hash: new SyncHook([\"hash\"]),\n      hashForChunk: new SyncHook([\"hash\", \"chunk\"]),\n      globalHashPaths: new SyncWaterfallHook([\"paths\"]),\n      globalHash: new SyncBailHook([\"chunk\", \"paths\"]),\n      // TODO this should be moved somewhere else\n      // It's weird here\n      hotBootstrap: new SyncWaterfallHook([\"source\", \"chunk\", \"hash\"])\n    };\n    this.hooks.startup.tap(\"MainTemplate\", (source, chunk, hash) => {\n      /** @type {string[]} */\n      const buf = [];\n      if (chunk.entryModule) {\n        buf.push(\"// Load entry module and return exports\");\n        buf.push(`return ${this.renderRequireFunctionForModule(hash, chunk, JSON.stringify(chunk.entryModule.id))}(${this.requireFn}.s = ${JSON.stringify(chunk.entryModule.id)});`);\n      }\n      return Template.asString(buf);\n    });\n    this.hooks.render.tap(\"MainTemplate\", (bootstrapSource, chunk, hash, moduleTemplate, dependencyTemplates) => {\n      const source = new ConcatSource();\n      source.add(\"/******/ (function(modules) { // webpackBootstrap\\n\");\n      source.add(new PrefixSource(\"/******/\", bootstrapSource));\n      source.add(\"/******/ })\\n\");\n      source.add(\"/************************************************************************/\\n\");\n      source.add(\"/******/ (\");\n      source.add(this.hooks.modules.call(new RawSource(\"\"), chunk, hash, moduleTemplate, dependencyTemplates));\n      source.add(\")\");\n      return source;\n    });\n    this.hooks.localVars.tap(\"MainTemplate\", (source, chunk, hash) => {\n      return Template.asString([source, \"// The module cache\", \"var installedModules = {};\"]);\n    });\n    this.hooks.require.tap(\"MainTemplate\", (source, chunk, hash) => {\n      return Template.asString([source, \"// Check if module is in cache\", \"if(installedModules[moduleId]) {\", Template.indent(\"return installedModules[moduleId].exports;\"), \"}\", \"// Create a new module (and put it into the cache)\", \"var module = installedModules[moduleId] = {\", Template.indent(this.hooks.moduleObj.call(\"\", chunk, hash, \"moduleId\")), \"};\", \"\", Template.asString(outputOptions.strictModuleExceptionHandling ? [\"// Execute the module function\", \"var threw = true;\", \"try {\", Template.indent([`modules[moduleId].call(module.exports, module, module.exports, ${this.renderRequireFunctionForModule(hash, chunk, \"moduleId\")});`, \"threw = false;\"]), \"} finally {\", Template.indent([\"if(threw) delete installedModules[moduleId];\"]), \"}\"] : [\"// Execute the module function\", `modules[moduleId].call(module.exports, module, module.exports, ${this.renderRequireFunctionForModule(hash, chunk, \"moduleId\")});`]), \"\", \"// Flag the module as loaded\", \"module.l = true;\", \"\", \"// Return the exports of the module\", \"return module.exports;\"]);\n    });\n    this.hooks.moduleObj.tap(\"MainTemplate\", (source, chunk, hash, varModuleId) => {\n      return Template.asString([\"i: moduleId,\", \"l: false,\", \"exports: {}\"]);\n    });\n    this.hooks.requireExtensions.tap(\"MainTemplate\", (source, chunk, hash) => {\n      const buf = [];\n      const chunkMaps = chunk.getChunkMaps();\n      // Check if there are non initial chunks which need to be imported using require-ensure\n      if (Object.keys(chunkMaps.hash).length) {\n        buf.push(\"// This file contains only the entry chunk.\");\n        buf.push(\"// The chunk loading function for additional chunks\");\n        buf.push(`${this.requireFn}.e = function requireEnsure(chunkId) {`);\n        buf.push(Template.indent(\"var promises = [];\"));\n        buf.push(Template.indent(this.hooks.requireEnsure.call(\"\", chunk, hash, \"chunkId\")));\n        buf.push(Template.indent(\"return Promise.all(promises);\"));\n        buf.push(\"};\");\n      } else if (chunk.hasModuleInGraph(m => m.blocks.some(b => b.chunkGroup && b.chunkGroup.chunks.length > 0))) {\n        // There async blocks in the graph, so we need to add an empty requireEnsure\n        // function anyway. This can happen with multiple entrypoints.\n        buf.push(\"// The chunk loading function for additional chunks\");\n        buf.push(\"// Since all referenced chunks are already included\");\n        buf.push(\"// in this file, this function is empty here.\");\n        buf.push(`${this.requireFn}.e = function requireEnsure() {`);\n        buf.push(Template.indent(\"return Promise.resolve();\"));\n        buf.push(\"};\");\n      }\n      buf.push(\"\");\n      buf.push(\"// expose the modules object (__webpack_modules__)\");\n      buf.push(`${this.requireFn}.m = modules;`);\n      buf.push(\"\");\n      buf.push(\"// expose the module cache\");\n      buf.push(`${this.requireFn}.c = installedModules;`);\n      buf.push(\"\");\n      buf.push(\"// define getter function for harmony exports\");\n      buf.push(`${this.requireFn}.d = function(exports, name, getter) {`);\n      buf.push(Template.indent([`if(!${this.requireFn}.o(exports, name)) {`, Template.indent([\"Object.defineProperty(exports, name, { enumerable: true, get: getter });\"]), \"}\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// define __esModule on exports\");\n      buf.push(`${this.requireFn}.r = function(exports) {`);\n      buf.push(Template.indent([\"if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\", Template.indent([\"Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\"]), \"}\", \"Object.defineProperty(exports, '__esModule', { value: true });\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// create a fake namespace object\");\n      buf.push(\"// mode & 1: value is a module id, require it\");\n      buf.push(\"// mode & 2: merge all properties of value into the ns\");\n      buf.push(\"// mode & 4: return value when already ns object\");\n      buf.push(\"// mode & 8|1: behave like require\");\n      buf.push(`${this.requireFn}.t = function(value, mode) {`);\n      buf.push(Template.indent([`if(mode & 1) value = ${this.requireFn}(value);`, `if(mode & 8) return value;`, \"if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\", \"var ns = Object.create(null);\", `${this.requireFn}.r(ns);`, \"Object.defineProperty(ns, 'default', { enumerable: true, value: value });\", \"if(mode & 2 && typeof value != 'string') for(var key in value) \" + `${this.requireFn}.d(ns, key, function(key) { ` + \"return value[key]; \" + \"}.bind(null, key));\", \"return ns;\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// getDefaultExport function for compatibility with non-harmony modules\");\n      buf.push(this.requireFn + \".n = function(module) {\");\n      buf.push(Template.indent([\"var getter = module && module.__esModule ?\", Template.indent([\"function getDefault() { return module['default']; } :\", \"function getModuleExports() { return module; };\"]), `${this.requireFn}.d(getter, 'a', getter);`, \"return getter;\"]));\n      buf.push(\"};\");\n      buf.push(\"\");\n      buf.push(\"// Object.prototype.hasOwnProperty.call\");\n      buf.push(`${this.requireFn}.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };`);\n      const publicPath = this.getPublicPath({\n        hash: hash\n      });\n      buf.push(\"\");\n      buf.push(\"// __webpack_public_path__\");\n      buf.push(`${this.requireFn}.p = ${JSON.stringify(publicPath)};`);\n      return Template.asString(buf);\n    });\n    this.requireFn = \"__webpack_require__\";\n  }\n\n  /**\n   *\n   * @param {RenderManifestOptions} options render manifest options\n   * @returns {TODO[]} returns render manifest\n   */\n  getRenderManifest(options) {\n    const result = [];\n    this.hooks.renderManifest.call(result, options);\n    return result;\n  }\n\n  /**\n   * TODO webpack 5: remove moduleTemplate and dependencyTemplates\n   * @param {string} hash hash to be used for render call\n   * @param {Chunk} chunk Chunk instance\n   * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates\n   * @returns {string[]} the generated source of the bootstrap code\n   */\n  renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates) {\n    const buf = [];\n    buf.push(this.hooks.bootstrap.call(\"\", chunk, hash, moduleTemplate, dependencyTemplates));\n    buf.push(this.hooks.localVars.call(\"\", chunk, hash));\n    buf.push(\"\");\n    buf.push(\"// The require function\");\n    buf.push(`function ${this.requireFn}(moduleId) {`);\n    buf.push(Template.indent(this.hooks.require.call(\"\", chunk, hash)));\n    buf.push(\"}\");\n    buf.push(\"\");\n    buf.push(Template.asString(this.hooks.requireExtensions.call(\"\", chunk, hash)));\n    buf.push(\"\");\n    buf.push(Template.asString(this.hooks.beforeStartup.call(\"\", chunk, hash)));\n    buf.push(Template.asString(this.hooks.startup.call(\"\", chunk, hash)));\n    return buf;\n  }\n\n  /**\n   * @param {string} hash hash to be used for render call\n   * @param {Chunk} chunk Chunk instance\n   * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates\n   * @returns {ConcatSource} the newly generated source from rendering\n   */\n  render(hash, chunk, moduleTemplate, dependencyTemplates) {\n    const buf = this.renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates);\n    let source = this.hooks.render.call(new OriginalSource(Template.prefix(buf, \" \\t\") + \"\\n\", \"webpack/bootstrap\"), chunk, hash, moduleTemplate, dependencyTemplates);\n    if (chunk.hasEntryModule()) {\n      source = this.hooks.renderWithEntry.call(source, chunk, hash);\n    }\n    if (!source) {\n      throw new Error(\"Compiler error: MainTemplate plugin 'render' should return something\");\n    }\n    chunk.rendered = true;\n    return new ConcatSource(source, \";\");\n  }\n\n  /**\n   *\n   * @param {string} hash hash for render fn\n   * @param {Chunk} chunk Chunk instance for require\n   * @param {(number|string)=} varModuleId module id\n   * @returns {TODO} the moduleRequire hook call return signature\n   */\n  renderRequireFunctionForModule(hash, chunk, varModuleId) {\n    return this.hooks.moduleRequire.call(this.requireFn, chunk, hash, varModuleId);\n  }\n\n  /**\n   *\n   * @param {string} hash hash for render add fn\n   * @param {Chunk} chunk Chunk instance for require add fn\n   * @param {(string|number)=} varModuleId module id\n   * @param {Module} varModule Module instance\n   * @returns {TODO} renderAddModule call\n   */\n  renderAddModule(hash, chunk, varModuleId, varModule) {\n    return this.hooks.addModule.call(`modules[${varModuleId}] = ${varModule};`, chunk, hash, varModuleId, varModule);\n  }\n\n  /**\n   *\n   * @param {string} hash string hash\n   * @param {number=} length length\n   * @returns {string} call hook return\n   */\n  renderCurrentHashCode(hash, length) {\n    length = length || Infinity;\n    return this.hooks.currentHash.call(JSON.stringify(hash.substr(0, length)), length);\n  }\n\n  /**\n   *\n   * @param {object} options get public path options\n   * @returns {string} hook call\n   */\n  getPublicPath(options) {\n    return this.hooks.assetPath.call(this.outputOptions.publicPath || \"\", options);\n  }\n  getAssetPath(path, options) {\n    return this.hooks.assetPath.call(path, options);\n  }\n\n  /**\n   * Updates hash with information from this template\n   * @param {Hash} hash the hash to update\n   * @returns {void}\n   */\n  updateHash(hash) {\n    hash.update(\"maintemplate\");\n    hash.update(\"3\");\n    this.hooks.hash.call(hash);\n  }\n\n  /**\n   * TODO webpack 5: remove moduleTemplate and dependencyTemplates\n   * Updates hash with chunk-specific information from this template\n   * @param {Hash} hash the hash to update\n   * @param {Chunk} chunk the chunk\n   * @param {ModuleTemplate} moduleTemplate ModuleTemplate instance for render\n   * @param {Map<Function, DependencyTemplate>} dependencyTemplates dependency templates\n   * @returns {void}\n   */\n  updateHashForChunk(hash, chunk, moduleTemplate, dependencyTemplates) {\n    this.updateHash(hash);\n    this.hooks.hashForChunk.call(hash, chunk);\n    for (const line of this.renderBootstrap(\"0000\", chunk, moduleTemplate, dependencyTemplates)) {\n      hash.update(line);\n    }\n  }\n  useChunkHash(chunk) {\n    const paths = this.hooks.globalHashPaths.call([]);\n    return !this.hooks.globalHash.call(chunk, paths);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}