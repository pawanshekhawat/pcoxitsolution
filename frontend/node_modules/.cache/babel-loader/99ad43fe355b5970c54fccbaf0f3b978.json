{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst {\n  RawSource,\n  ReplaceSource\n} = require(\"webpack-sources\");\n\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate */\n/** @typedef {import(\"./RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n/** @typedef {(d: Dependency) => boolean} DependencyFilterFunction */\n/** @typedef {Map<Function, DependencyTemplate>} DependencyTemplates */\n\nclass DependenciesBlockVariable {\n  /**\n   * Creates an instance of DependenciesBlockVariable.\n   * @param {string} name name of DependenciesBlockVariable\n   * @param {string} expression expression string\n   * @param {Dependency[]=} dependencies dependencies tied to this varaiable\n   */\n  constructor(name, expression, dependencies) {\n    this.name = name;\n    this.expression = expression;\n    this.dependencies = dependencies || [];\n  }\n\n  /**\n   * @param {Hash} hash hash for instance to update\n   * @returns {void}\n   */\n  updateHash(hash) {\n    hash.update(this.name);\n    hash.update(this.expression);\n    for (const d of this.dependencies) {\n      d.updateHash(hash);\n    }\n  }\n\n  /**\n   * @param {DependencyTemplates} dependencyTemplates Dependency constructors and templates Map.\n   * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate to generate expression souce\n   * @returns {ReplaceSource} returns constructed source for expression via templates\n   */\n  expressionSource(dependencyTemplates, runtimeTemplate) {\n    const source = new ReplaceSource(new RawSource(this.expression));\n    for (const dep of this.dependencies) {\n      const template = dependencyTemplates.get(dep.constructor);\n      if (!template) {\n        throw new Error(`No template for dependency: ${dep.constructor.name}`);\n      }\n      template.apply(dep, source, runtimeTemplate, dependencyTemplates);\n    }\n    return source;\n  }\n  disconnect() {\n    for (const d of this.dependencies) {\n      d.disconnect();\n    }\n  }\n  hasDependencies(filter) {\n    if (filter) {\n      return this.dependencies.some(filter);\n    }\n    return this.dependencies.length > 0;\n  }\n}\nmodule.exports = DependenciesBlockVariable;","map":null,"metadata":{},"sourceType":"script"}