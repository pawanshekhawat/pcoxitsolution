{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Parser = require(\"./Parser\");\nconst Template = require(\"./Template\");\nconst {\n  ConcatSource\n} = require(\"webpack-sources\");\nconst JavascriptGenerator = require(\"./JavascriptGenerator\");\nconst createHash = require(\"./util/createHash\");\nclass JavascriptModulesPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"JavascriptModulesPlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      normalModuleFactory.hooks.createParser.for(\"javascript/auto\").tap(\"JavascriptModulesPlugin\", options => {\n        return new Parser(options, \"auto\");\n      });\n      normalModuleFactory.hooks.createParser.for(\"javascript/dynamic\").tap(\"JavascriptModulesPlugin\", options => {\n        return new Parser(options, \"script\");\n      });\n      normalModuleFactory.hooks.createParser.for(\"javascript/esm\").tap(\"JavascriptModulesPlugin\", options => {\n        return new Parser(options, \"module\");\n      });\n      normalModuleFactory.hooks.createGenerator.for(\"javascript/auto\").tap(\"JavascriptModulesPlugin\", () => {\n        return new JavascriptGenerator();\n      });\n      normalModuleFactory.hooks.createGenerator.for(\"javascript/dynamic\").tap(\"JavascriptModulesPlugin\", () => {\n        return new JavascriptGenerator();\n      });\n      normalModuleFactory.hooks.createGenerator.for(\"javascript/esm\").tap(\"JavascriptModulesPlugin\", () => {\n        return new JavascriptGenerator();\n      });\n      compilation.mainTemplate.hooks.renderManifest.tap(\"JavascriptModulesPlugin\", (result, options) => {\n        const chunk = options.chunk;\n        const hash = options.hash;\n        const fullHash = options.fullHash;\n        const outputOptions = options.outputOptions;\n        const moduleTemplates = options.moduleTemplates;\n        const dependencyTemplates = options.dependencyTemplates;\n        const filenameTemplate = chunk.filenameTemplate || outputOptions.filename;\n        const useChunkHash = compilation.mainTemplate.useChunkHash(chunk);\n        result.push({\n          render: () => compilation.mainTemplate.render(hash, chunk, moduleTemplates.javascript, dependencyTemplates),\n          filenameTemplate,\n          pathOptions: {\n            noChunkHash: !useChunkHash,\n            contentHashType: \"javascript\",\n            chunk\n          },\n          identifier: `chunk${chunk.id}`,\n          hash: useChunkHash ? chunk.hash : fullHash\n        });\n        return result;\n      });\n      compilation.mainTemplate.hooks.modules.tap(\"JavascriptModulesPlugin\", (source, chunk, hash, moduleTemplate, dependencyTemplates) => {\n        return Template.renderChunkModules(chunk, m => typeof m.source === \"function\", moduleTemplate, dependencyTemplates, \"/******/ \");\n      });\n      compilation.chunkTemplate.hooks.renderManifest.tap(\"JavascriptModulesPlugin\", (result, options) => {\n        const chunk = options.chunk;\n        const outputOptions = options.outputOptions;\n        const moduleTemplates = options.moduleTemplates;\n        const dependencyTemplates = options.dependencyTemplates;\n        const filenameTemplate = chunk.filenameTemplate || outputOptions.chunkFilename;\n        result.push({\n          render: () => this.renderJavascript(compilation.chunkTemplate, chunk, moduleTemplates.javascript, dependencyTemplates),\n          filenameTemplate,\n          pathOptions: {\n            chunk,\n            contentHashType: \"javascript\"\n          },\n          identifier: `chunk${chunk.id}`,\n          hash: chunk.hash\n        });\n        return result;\n      });\n      compilation.hooks.contentHash.tap(\"JavascriptModulesPlugin\", chunk => {\n        const outputOptions = compilation.outputOptions;\n        const {\n          hashSalt,\n          hashDigest,\n          hashDigestLength,\n          hashFunction\n        } = outputOptions;\n        const hash = createHash(hashFunction);\n        if (hashSalt) hash.update(hashSalt);\n        const template = chunk.hasRuntime() ? compilation.mainTemplate : compilation.chunkTemplate;\n        hash.update(`${chunk.id} `);\n        hash.update(chunk.ids ? chunk.ids.join(\",\") : \"\");\n        template.updateHashForChunk(hash, chunk, compilation.moduleTemplates.javascript, compilation.dependencyTemplates);\n        for (const m of chunk.modulesIterable) {\n          if (typeof m.source === \"function\") {\n            hash.update(m.hash);\n          }\n        }\n        chunk.contentHash.javascript = hash.digest(hashDigest).substr(0, hashDigestLength);\n      });\n    });\n  }\n  renderJavascript(chunkTemplate, chunk, moduleTemplate, dependencyTemplates) {\n    const moduleSources = Template.renderChunkModules(chunk, m => typeof m.source === \"function\", moduleTemplate, dependencyTemplates);\n    const core = chunkTemplate.hooks.modules.call(moduleSources, chunk, moduleTemplate, dependencyTemplates);\n    let source = chunkTemplate.hooks.render.call(core, chunk, moduleTemplate, dependencyTemplates);\n    if (chunk.hasEntryModule()) {\n      source = chunkTemplate.hooks.renderWithEntry.call(source, chunk);\n    }\n    chunk.rendered = true;\n    return new ConcatSource(source, \";\");\n  }\n}\nmodule.exports = JavascriptModulesPlugin;","map":null,"metadata":{},"sourceType":"script"}