{"ast":null,"code":"const fs = require(\"fs\");\nconst path = require(\"path\");\nconst mkdirp = require(\"mkdirp\");\nconst {\n  Tracer\n} = require(\"chrome-trace-event\");\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../../schemas/plugins/debug/ProfilingPlugin.json\");\n\n/** @typedef {import(\"../../declarations/plugins/debug/ProfilingPlugin\").ProfilingPluginOptions} ProfilingPluginOptions */\n\nlet inspector = undefined;\ntry {\n  // eslint-disable-next-line node/no-unsupported-features/node-builtins\n  inspector = require(\"inspector\");\n} catch (e) {\n  console.log(\"Unable to CPU profile in < node 8.0\");\n}\nclass Profiler {\n  constructor(inspector) {\n    this.session = undefined;\n    this.inspector = inspector;\n  }\n  hasSession() {\n    return this.session !== undefined;\n  }\n  startProfiling() {\n    if (this.inspector === undefined) {\n      return Promise.resolve();\n    }\n    try {\n      this.session = new inspector.Session();\n      this.session.connect();\n    } catch (_) {\n      this.session = undefined;\n      return Promise.resolve();\n    }\n    return Promise.all([this.sendCommand(\"Profiler.setSamplingInterval\", {\n      interval: 100\n    }), this.sendCommand(\"Profiler.enable\"), this.sendCommand(\"Profiler.start\")]);\n  }\n  sendCommand(method, params) {\n    if (this.hasSession()) {\n      return new Promise((res, rej) => {\n        return this.session.post(method, params, (err, params) => {\n          if (err !== null) {\n            rej(err);\n          } else {\n            res(params);\n          }\n        });\n      });\n    } else {\n      return Promise.resolve();\n    }\n  }\n  destroy() {\n    if (this.hasSession()) {\n      this.session.disconnect();\n    }\n    return Promise.resolve();\n  }\n  stopProfiling() {\n    return this.sendCommand(\"Profiler.stop\");\n  }\n}\n\n/**\n * @typedef {Object} Trace\n * @description an object that wraps Tracer and Profiler with a counter\n * @property {Tracer} trace instance of Tracer\n * @property {number} counter Counter\n * @property {Profiler} profiler instance of Profiler\n * @property {Function} end the end function\n */\n\n/**\n * @param {string} outputPath The location where to write the log.\n * @returns {Trace} The trace object\n */\nconst createTrace = outputPath => {\n  const trace = new Tracer({\n    noStream: true\n  });\n  const profiler = new Profiler(inspector);\n  if (/\\/|\\\\/.test(outputPath)) {\n    const dirPath = path.dirname(outputPath);\n    mkdirp.sync(dirPath);\n  }\n  const fsStream = fs.createWriteStream(outputPath);\n  let counter = 0;\n  trace.pipe(fsStream);\n  // These are critical events that need to be inserted so that tools like\n  // chrome dev tools can load the profile.\n  trace.instantEvent({\n    name: \"TracingStartedInPage\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\",\n        page: \"0xfff\",\n        frames: [{\n          frame: \"0xfff\",\n          url: \"webpack\",\n          name: \"\"\n        }]\n      }\n    }\n  });\n  trace.instantEvent({\n    name: \"TracingStartedInBrowser\",\n    id: ++counter,\n    cat: [\"disabled-by-default-devtools.timeline\"],\n    args: {\n      data: {\n        sessionId: \"-1\"\n      }\n    }\n  });\n  return {\n    trace,\n    counter,\n    profiler,\n    end: callback => {\n      // Wait until the write stream finishes.\n      fsStream.on(\"finish\", () => {\n        callback();\n      });\n      // Tear down the readable trace stream.\n      trace.push(null);\n    }\n  };\n};\nconst pluginName = \"ProfilingPlugin\";\nclass ProfilingPlugin {\n  /**\n   * @param {ProfilingPluginOptions=} opts options object\n   */\n  constructor(opts) {\n    validateOptions(schema, opts || {}, \"Profiling plugin\");\n    opts = opts || {};\n    this.outputPath = opts.outputPath || \"events.json\";\n  }\n  apply(compiler) {\n    const tracer = createTrace(this.outputPath);\n    tracer.profiler.startProfiling();\n\n    // Compiler Hooks\n    Object.keys(compiler.hooks).forEach(hookName => {\n      compiler.hooks[hookName].intercept(makeInterceptorFor(\"Compiler\", tracer)(hookName));\n    });\n    Object.keys(compiler.resolverFactory.hooks).forEach(hookName => {\n      compiler.resolverFactory.hooks[hookName].intercept(makeInterceptorFor(\"Resolver\", tracer)(hookName));\n    });\n    compiler.hooks.compilation.tap(pluginName, (compilation, {\n      normalModuleFactory,\n      contextModuleFactory\n    }) => {\n      interceptAllHooksFor(compilation, tracer, \"Compilation\");\n      interceptAllHooksFor(normalModuleFactory, tracer, \"Normal Module Factory\");\n      interceptAllHooksFor(contextModuleFactory, tracer, \"Context Module Factory\");\n      interceptAllParserHooks(normalModuleFactory, tracer);\n      interceptTemplateInstancesFrom(compilation, tracer);\n    });\n\n    // We need to write out the CPU profile when we are all done.\n    compiler.hooks.done.tapAsync({\n      name: pluginName,\n      stage: Infinity\n    }, (stats, callback) => {\n      tracer.profiler.stopProfiling().then(parsedResults => {\n        if (parsedResults === undefined) {\n          tracer.profiler.destroy();\n          tracer.trace.flush();\n          tracer.end(callback);\n          return;\n        }\n        const cpuStartTime = parsedResults.profile.startTime;\n        const cpuEndTime = parsedResults.profile.endTime;\n        tracer.trace.completeEvent({\n          name: \"TaskQueueManager::ProcessTaskFromWorkQueue\",\n          id: ++tracer.counter,\n          cat: [\"toplevel\"],\n          ts: cpuStartTime,\n          args: {\n            src_file: \"../../ipc/ipc_moji_bootstrap.cc\",\n            src_func: \"Accept\"\n          }\n        });\n        tracer.trace.completeEvent({\n          name: \"EvaluateScript\",\n          id: ++tracer.counter,\n          cat: [\"devtools.timeline\"],\n          ts: cpuStartTime,\n          dur: cpuEndTime - cpuStartTime,\n          args: {\n            data: {\n              url: \"webpack\",\n              lineNumber: 1,\n              columnNumber: 1,\n              frame: \"0xFFF\"\n            }\n          }\n        });\n        tracer.trace.instantEvent({\n          name: \"CpuProfile\",\n          id: ++tracer.counter,\n          cat: [\"disabled-by-default-devtools.timeline\"],\n          ts: cpuEndTime,\n          args: {\n            data: {\n              cpuProfile: parsedResults.profile\n            }\n          }\n        });\n        tracer.profiler.destroy();\n        tracer.trace.flush();\n        tracer.end(callback);\n      });\n    });\n  }\n}\nconst interceptTemplateInstancesFrom = (compilation, tracer) => {\n  const {\n    mainTemplate,\n    chunkTemplate,\n    hotUpdateChunkTemplate,\n    moduleTemplates\n  } = compilation;\n  const {\n    javascript,\n    webassembly\n  } = moduleTemplates;\n  [{\n    instance: mainTemplate,\n    name: \"MainTemplate\"\n  }, {\n    instance: chunkTemplate,\n    name: \"ChunkTemplate\"\n  }, {\n    instance: hotUpdateChunkTemplate,\n    name: \"HotUpdateChunkTemplate\"\n  }, {\n    instance: javascript,\n    name: \"JavaScriptModuleTemplate\"\n  }, {\n    instance: webassembly,\n    name: \"WebAssemblyModuleTemplate\"\n  }].forEach(templateObject => {\n    Object.keys(templateObject.instance.hooks).forEach(hookName => {\n      templateObject.instance.hooks[hookName].intercept(makeInterceptorFor(templateObject.name, tracer)(hookName));\n    });\n  });\n};\nconst interceptAllHooksFor = (instance, tracer, logLabel) => {\n  if (Reflect.has(instance, \"hooks\")) {\n    Object.keys(instance.hooks).forEach(hookName => {\n      instance.hooks[hookName].intercept(makeInterceptorFor(logLabel, tracer)(hookName));\n    });\n  }\n};\nconst interceptAllParserHooks = (moduleFactory, tracer) => {\n  const moduleTypes = [\"javascript/auto\", \"javascript/dynamic\", \"javascript/esm\", \"json\", \"webassembly/experimental\"];\n  moduleTypes.forEach(moduleType => {\n    moduleFactory.hooks.parser.for(moduleType).tap(\"ProfilingPlugin\", (parser, parserOpts) => {\n      interceptAllHooksFor(parser, tracer, \"Parser\");\n    });\n  });\n};\nconst makeInterceptorFor = (instance, tracer) => hookName => ({\n  register: ({\n    name,\n    type,\n    context,\n    fn\n  }) => {\n    const newFn = makeNewProfiledTapFn(hookName, tracer, {\n      name,\n      type,\n      fn\n    });\n    return {\n      name,\n      type,\n      context,\n      fn: newFn\n    };\n  }\n});\n\n// TODO improve typing\n/** @typedef {(...args: TODO[]) => void | Promise<TODO>} PluginFunction */\n\n/**\n * @param {string} hookName Name of the hook to profile.\n * @param {Trace} tracer The trace object.\n * @param {object} options Options for the profiled fn.\n * @param {string} options.name Plugin name\n * @param {string} options.type Plugin type (sync | async | promise)\n * @param {PluginFunction} options.fn Plugin function\n * @returns {PluginFunction} Chainable hooked function.\n */\nconst makeNewProfiledTapFn = (hookName, tracer, {\n  name,\n  type,\n  fn\n}) => {\n  const defaultCategory = [\"blink.user_timing\"];\n  switch (type) {\n    case \"promise\":\n      return (...args) => {\n        const id = ++tracer.counter;\n        tracer.trace.begin({\n          name,\n          id,\n          cat: defaultCategory\n        });\n        const promise = /** @type {Promise<*>} */fn(...args);\n        return promise.then(r => {\n          tracer.trace.end({\n            name,\n            id,\n            cat: defaultCategory\n          });\n          return r;\n        });\n      };\n    case \"async\":\n      return (...args) => {\n        const id = ++tracer.counter;\n        tracer.trace.begin({\n          name,\n          id,\n          cat: defaultCategory\n        });\n        fn(...args, (...r) => {\n          const callback = args.pop();\n          tracer.trace.end({\n            name,\n            id,\n            cat: defaultCategory\n          });\n          callback(...r);\n        });\n      };\n    case \"sync\":\n      return (...args) => {\n        const id = ++tracer.counter;\n        // Do not instrument ourself due to the CPU\n        // profile needing to be the last event in the trace.\n        if (name === pluginName) {\n          return fn(...args);\n        }\n        tracer.trace.begin({\n          name,\n          id,\n          cat: defaultCategory\n        });\n        let r;\n        try {\n          r = fn(...args);\n        } catch (error) {\n          tracer.trace.end({\n            name,\n            id,\n            cat: defaultCategory\n          });\n          throw error;\n        }\n        tracer.trace.end({\n          name,\n          id,\n          cat: defaultCategory\n        });\n        return r;\n      };\n    default:\n      break;\n  }\n};\nmodule.exports = ProfilingPlugin;\nmodule.exports.Profiler = Profiler;","map":null,"metadata":{},"sourceType":"script"}