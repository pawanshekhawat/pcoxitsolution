{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n\t*/\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst util = require(\"util\");\nconst {\n  CachedSource\n} = require(\"webpack-sources\");\nconst {\n  Tapable,\n  SyncHook,\n  SyncBailHook,\n  SyncWaterfallHook,\n  AsyncSeriesHook\n} = require(\"tapable\");\nconst EntryModuleNotFoundError = require(\"./EntryModuleNotFoundError\");\nconst ModuleNotFoundError = require(\"./ModuleNotFoundError\");\nconst ModuleDependencyWarning = require(\"./ModuleDependencyWarning\");\nconst ModuleDependencyError = require(\"./ModuleDependencyError\");\nconst ChunkGroup = require(\"./ChunkGroup\");\nconst Chunk = require(\"./Chunk\");\nconst Entrypoint = require(\"./Entrypoint\");\nconst MainTemplate = require(\"./MainTemplate\");\nconst ChunkTemplate = require(\"./ChunkTemplate\");\nconst HotUpdateChunkTemplate = require(\"./HotUpdateChunkTemplate\");\nconst ModuleTemplate = require(\"./ModuleTemplate\");\nconst RuntimeTemplate = require(\"./RuntimeTemplate\");\nconst ChunkRenderError = require(\"./ChunkRenderError\");\nconst AsyncDependencyToInitialChunkError = require(\"./AsyncDependencyToInitialChunkError\");\nconst Stats = require(\"./Stats\");\nconst Semaphore = require(\"./util/Semaphore\");\nconst createHash = require(\"./util/createHash\");\nconst Queue = require(\"./util/Queue\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst GraphHelpers = require(\"./GraphHelpers\");\nconst ModuleDependency = require(\"./dependencies/ModuleDependency\");\nconst compareLocations = require(\"./compareLocations\");\n\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./DependenciesBlockVariable\")} DependenciesBlockVariable */\n/** @typedef {import(\"./dependencies/SingleEntryDependency\")} SingleEntryDependency */\n/** @typedef {import(\"./dependencies/MultiEntryDependency\")} MultiEntryDependency */\n/** @typedef {import(\"./dependencies/DllEntryDependency\")} DllEntryDependency */\n/** @typedef {import(\"./dependencies/DependencyReference\")} DependencyReference */\n/** @typedef {import(\"./DependenciesBlock\")} DependenciesBlock */\n/** @typedef {import(\"./AsyncDependenciesBlock\")} AsyncDependenciesBlock */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Dependency\").DependencyTemplate} DependencyTemplate */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\n// TODO use @callback\n/** @typedef {{[assetName: string]: Source}} CompilationAssets */\n/** @typedef {(err: Error|null, result?: Module) => void } ModuleCallback */\n/** @typedef {(err?: Error|null, result?: Module) => void } ModuleChainCallback */\n/** @typedef {(module: Module) => void} OnModuleCallback */\n/** @typedef {(err?: Error|null) => void} Callback */\n/** @typedef {(d: Dependency) => any} DepBlockVarDependenciesCallback */\n/** @typedef {new (...args: any[]) => Dependency} DepConstructor */\n/** @typedef {{apply: () => void}} Plugin */\n\n/**\n * @typedef {Object} ModuleFactoryCreateDataContextInfo\n * @property {string} issuer\n * @property {string} compiler\n */\n\n/**\n * @typedef {Object} ModuleFactoryCreateData\n * @property {ModuleFactoryCreateDataContextInfo} contextInfo\n * @property {any=} resolveOptions\n * @property {string} context\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} ModuleFactory\n * @property {(data: ModuleFactoryCreateData, callback: ModuleCallback) => any} create\n */\n\n/**\n * @typedef {Object} SortedDependency\n * @property {ModuleFactory} factory\n * @property {Dependency[]} dependencies\n */\n\n/**\n * @typedef {Object} DependenciesBlockLike\n * @property {Dependency[]} dependencies\n * @property {AsyncDependenciesBlock[]} blocks\n * @property {DependenciesBlockVariable[]} variables\n */\n\n/**\n * @param {Chunk} a first chunk to sort by id\n * @param {Chunk} b second chunk to sort by id\n * @returns {-1|0|1} sort value\n */\nconst byId = (a, b) => {\n  if (typeof a.id !== typeof b.id) {\n    return typeof a.id < typeof b.id ? -1 : 1;\n  }\n  if (a.id < b.id) return -1;\n  if (a.id > b.id) return 1;\n  return 0;\n};\n\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\nconst byIdOrIdentifier = (a, b) => {\n  if (typeof a.id !== typeof b.id) {\n    return typeof a.id < typeof b.id ? -1 : 1;\n  }\n  if (a.id < b.id) return -1;\n  if (a.id > b.id) return 1;\n  const identA = a.identifier();\n  const identB = b.identifier();\n  if (identA < identB) return -1;\n  if (identA > identB) return 1;\n  return 0;\n};\n\n/**\n * @param {Module} a first module to sort by\n * @param {Module} b second module to sort by\n * @returns {-1|0|1} sort value\n */\nconst byIndexOrIdentifier = (a, b) => {\n  if (a.index < b.index) return -1;\n  if (a.index > b.index) return 1;\n  const identA = a.identifier();\n  const identB = b.identifier();\n  if (identA < identB) return -1;\n  if (identA > identB) return 1;\n  return 0;\n};\n\n/**\n * @param {Compilation} a first compilation to sort by\n * @param {Compilation} b second compilation to sort by\n * @returns {-1|0|1} sort value\n */\nconst byNameOrHash = (a, b) => {\n  if (a.name < b.name) return -1;\n  if (a.name > b.name) return 1;\n  if (a.fullHash < b.fullHash) return -1;\n  if (a.fullHash > b.fullHash) return 1;\n  return 0;\n};\n\n/**\n * @template T\n * @param {Set<T>} a first set\n * @param {Set<T>} b second set\n * @returns {number} cmp\n */\nconst bySetSize = (a, b) => {\n  return a.size - b.size;\n};\n\n/**\n * @param {DependenciesBlockVariable[]} variables DepBlock Variables to iterate over\n * @param {DepBlockVarDependenciesCallback} fn callback to apply on iterated elements\n * @returns {void}\n */\nconst iterationBlockVariable = (variables, fn) => {\n  for (let indexVariable = 0; indexVariable < variables.length; indexVariable++) {\n    const varDep = variables[indexVariable].dependencies;\n    for (let indexVDep = 0; indexVDep < varDep.length; indexVDep++) {\n      fn(varDep[indexVDep]);\n    }\n  }\n};\n\n/**\n * @template T\n * @param {T[]} arr array of elements to iterate over\n * @param {function(T): void} fn callback applied to each element\n * @returns {void}\n */\nconst iterationOfArrayCallback = (arr, fn) => {\n  for (let index = 0; index < arr.length; index++) {\n    fn(arr[index]);\n  }\n};\n\n/**\n * @template T\n * @param {Set<T>} set set to add items to\n * @param {Set<T>} otherSet set to add items from\n * @returns {void}\n */\nconst addAllToSet = (set, otherSet) => {\n  for (const item of otherSet) {\n    set.add(item);\n  }\n};\nclass Compilation extends Tapable {\n  /**\n   * Creates an instance of Compilation.\n   * @param {Compiler} compiler the compiler which created the compilation\n   */\n  constructor(compiler) {\n    super();\n    this.hooks = {\n      /** @type {SyncHook<Module>} */\n      buildModule: new SyncHook([\"module\"]),\n      /** @type {SyncHook<Module>} */\n      rebuildModule: new SyncHook([\"module\"]),\n      /** @type {SyncHook<Module, Error>} */\n      failedModule: new SyncHook([\"module\", \"error\"]),\n      /** @type {SyncHook<Module>} */\n      succeedModule: new SyncHook([\"module\"]),\n      /** @type {SyncHook<Dependency, string>} */\n      addEntry: new SyncHook([\"entry\", \"name\"]),\n      /** @type {SyncHook<Dependency, string, Error>} */\n      failedEntry: new SyncHook([\"entry\", \"name\", \"error\"]),\n      /** @type {SyncHook<Dependency, string, Module>} */\n      succeedEntry: new SyncHook([\"entry\", \"name\", \"module\"]),\n      /** @type {SyncWaterfallHook<DependencyReference, Dependency, Module>} */\n      dependencyReference: new SyncWaterfallHook([\"dependencyReference\", \"dependency\", \"module\"]),\n      /** @type {SyncHook<Module[]>} */\n      finishModules: new SyncHook([\"modules\"]),\n      /** @type {SyncHook<Module>} */\n      finishRebuildingModule: new SyncHook([\"module\"]),\n      /** @type {SyncHook} */\n      unseal: new SyncHook([]),\n      /** @type {SyncHook} */\n      seal: new SyncHook([]),\n      /** @type {SyncHook} */\n      beforeChunks: new SyncHook([]),\n      /** @type {SyncHook<Chunk[]>} */\n      afterChunks: new SyncHook([\"chunks\"]),\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependenciesBasic: new SyncBailHook([\"modules\"]),\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependencies: new SyncBailHook([\"modules\"]),\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeDependenciesAdvanced: new SyncBailHook([\"modules\"]),\n      /** @type {SyncBailHook<Module[]>} */\n      afterOptimizeDependencies: new SyncHook([\"modules\"]),\n      /** @type {SyncHook} */\n      optimize: new SyncHook([]),\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModulesBasic: new SyncBailHook([\"modules\"]),\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModules: new SyncBailHook([\"modules\"]),\n      /** @type {SyncBailHook<Module[]>} */\n      optimizeModulesAdvanced: new SyncBailHook([\"modules\"]),\n      /** @type {SyncHook<Module[]>} */\n      afterOptimizeModules: new SyncHook([\"modules\"]),\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunksBasic: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunks: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n      /** @type {SyncBailHook<Chunk[], ChunkGroup[]>} */\n      optimizeChunksAdvanced: new SyncBailHook([\"chunks\", \"chunkGroups\"]),\n      /** @type {SyncHook<Chunk[], ChunkGroup[]>} */\n      afterOptimizeChunks: new SyncHook([\"chunks\", \"chunkGroups\"]),\n      /** @type {AsyncSeriesHook<Chunk[], Module[]>} */\n      optimizeTree: new AsyncSeriesHook([\"chunks\", \"modules\"]),\n      /** @type {SyncHook<Chunk[], Module[]>} */\n      afterOptimizeTree: new SyncHook([\"chunks\", \"modules\"]),\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModulesBasic: new SyncBailHook([\"chunks\", \"modules\"]),\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModules: new SyncBailHook([\"chunks\", \"modules\"]),\n      /** @type {SyncBailHook<Chunk[], Module[]>} */\n      optimizeChunkModulesAdvanced: new SyncBailHook([\"chunks\", \"modules\"]),\n      /** @type {SyncHook<Chunk[], Module[]>} */\n      afterOptimizeChunkModules: new SyncHook([\"chunks\", \"modules\"]),\n      /** @type {SyncBailHook} */\n      shouldRecord: new SyncBailHook([]),\n      /** @type {SyncHook<Module[], any>} */\n      reviveModules: new SyncHook([\"modules\", \"records\"]),\n      /** @type {SyncHook<Module[]>} */\n      optimizeModuleOrder: new SyncHook([\"modules\"]),\n      /** @type {SyncHook<Module[]>} */\n      advancedOptimizeModuleOrder: new SyncHook([\"modules\"]),\n      /** @type {SyncHook<Module[]>} */\n      beforeModuleIds: new SyncHook([\"modules\"]),\n      /** @type {SyncHook<Module[]>} */\n      moduleIds: new SyncHook([\"modules\"]),\n      /** @type {SyncHook<Module[]>} */\n      optimizeModuleIds: new SyncHook([\"modules\"]),\n      /** @type {SyncHook<Module[]>} */\n      afterOptimizeModuleIds: new SyncHook([\"modules\"]),\n      /** @type {SyncHook<Chunk[], any>} */\n      reviveChunks: new SyncHook([\"chunks\", \"records\"]),\n      /** @type {SyncHook<Chunk[]>} */\n      optimizeChunkOrder: new SyncHook([\"chunks\"]),\n      /** @type {SyncHook<Chunk[]>} */\n      beforeChunkIds: new SyncHook([\"chunks\"]),\n      /** @type {SyncHook<Chunk[]>} */\n      optimizeChunkIds: new SyncHook([\"chunks\"]),\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeChunkIds: new SyncHook([\"chunks\"]),\n      /** @type {SyncHook<Module[], any>} */\n      recordModules: new SyncHook([\"modules\", \"records\"]),\n      /** @type {SyncHook<Chunk[], any>} */\n      recordChunks: new SyncHook([\"chunks\", \"records\"]),\n      /** @type {SyncHook} */\n      beforeHash: new SyncHook([]),\n      /** @type {SyncHook<Chunk>} */\n      contentHash: new SyncHook([\"chunk\"]),\n      /** @type {SyncHook} */\n      afterHash: new SyncHook([]),\n      /** @type {SyncHook<any>} */\n      recordHash: new SyncHook([\"records\"]),\n      /** @type {SyncHook<Compilation, any>} */\n      record: new SyncHook([\"compilation\", \"records\"]),\n      /** @type {SyncHook} */\n      beforeModuleAssets: new SyncHook([]),\n      /** @type {SyncBailHook} */\n      shouldGenerateChunkAssets: new SyncBailHook([]),\n      /** @type {SyncHook} */\n      beforeChunkAssets: new SyncHook([]),\n      /** @type {SyncHook<Chunk[]>} */\n      additionalChunkAssets: new SyncHook([\"chunks\"]),\n      /** @type {AsyncSeriesHook} */\n      additionalAssets: new AsyncSeriesHook([]),\n      /** @type {AsyncSeriesHook<Chunk[]>} */\n      optimizeChunkAssets: new AsyncSeriesHook([\"chunks\"]),\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeChunkAssets: new SyncHook([\"chunks\"]),\n      /** @type {AsyncSeriesHook<CompilationAssets>} */\n      optimizeAssets: new AsyncSeriesHook([\"assets\"]),\n      /** @type {SyncHook<CompilationAssets>} */\n      afterOptimizeAssets: new SyncHook([\"assets\"]),\n      /** @type {SyncBailHook} */\n      needAdditionalSeal: new SyncBailHook([]),\n      /** @type {AsyncSeriesHook} */\n      afterSeal: new AsyncSeriesHook([]),\n      /** @type {SyncHook<Chunk, Hash>} */\n      chunkHash: new SyncHook([\"chunk\", \"chunkHash\"]),\n      /** @type {SyncHook<Module, string>} */\n      moduleAsset: new SyncHook([\"module\", \"filename\"]),\n      /** @type {SyncHook<Chunk, string>} */\n      chunkAsset: new SyncHook([\"chunk\", \"filename\"]),\n      /** @type {SyncWaterfallHook<string, TODO>} */\n      assetPath: new SyncWaterfallHook([\"filename\", \"data\"]),\n      // TODO MainTemplate\n\n      /** @type {SyncBailHook} */\n      needAdditionalPass: new SyncBailHook([]),\n      /** @type {SyncHook<Compiler, string, number>} */\n      childCompiler: new SyncHook([\"childCompiler\", \"compilerName\", \"compilerIndex\"]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n      /** @type {SyncHook<object, Module>} */\n      normalModuleLoader: new SyncHook([\"loaderContext\", \"module\"]),\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunksBasic: new SyncBailHook([\"chunks\"]),\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunks: new SyncBailHook([\"chunks\"]),\n      /** @type {SyncBailHook<Chunk[]>} */\n      optimizeExtractedChunksAdvanced: new SyncBailHook([\"chunks\"]),\n      /** @type {SyncHook<Chunk[]>} */\n      afterOptimizeExtractedChunks: new SyncHook([\"chunks\"])\n    };\n    this._pluginCompat.tap(\"Compilation\", options => {\n      switch (options.name) {\n        case \"optimize-tree\":\n        case \"additional-assets\":\n        case \"optimize-chunk-assets\":\n        case \"optimize-assets\":\n        case \"after-seal\":\n          options.async = true;\n          break;\n      }\n    });\n    /** @type {string=} */\n    this.name = undefined;\n    /** @type {Compiler} */\n    this.compiler = compiler;\n    this.resolverFactory = compiler.resolverFactory;\n    this.inputFileSystem = compiler.inputFileSystem;\n    this.requestShortener = compiler.requestShortener;\n    const options = compiler.options;\n    this.options = options;\n    this.outputOptions = options && options.output;\n    /** @type {boolean=} */\n    this.bail = options && options.bail;\n    this.profile = options && options.profile;\n    this.performance = options && options.performance;\n    this.mainTemplate = new MainTemplate(this.outputOptions);\n    this.chunkTemplate = new ChunkTemplate(this.outputOptions);\n    this.hotUpdateChunkTemplate = new HotUpdateChunkTemplate(this.outputOptions);\n    this.runtimeTemplate = new RuntimeTemplate(this.outputOptions, this.requestShortener);\n    this.moduleTemplates = {\n      javascript: new ModuleTemplate(this.runtimeTemplate, \"javascript\"),\n      webassembly: new ModuleTemplate(this.runtimeTemplate, \"webassembly\")\n    };\n    this.semaphore = new Semaphore(options.parallelism || 100);\n    this.entries = [];\n    /** @private @type {{name: string, request: string, module: Module}[]} */\n    this._preparedEntrypoints = [];\n    this.entrypoints = new Map();\n    /** @type {Chunk[]} */\n    this.chunks = [];\n    /** @type {ChunkGroup[]} */\n    this.chunkGroups = [];\n    /** @type {Map<string, ChunkGroup>} */\n    this.namedChunkGroups = new Map();\n    /** @type {Map<string, Chunk>} */\n    this.namedChunks = new Map();\n    /** @type {Module[]} */\n    this.modules = [];\n    /** @private @type {Map<string, Module>} */\n    this._modules = new Map();\n    this.cache = null;\n    this.records = null;\n    /** @type {string[]} */\n    this.additionalChunkAssets = [];\n    /** @type {CompilationAssets} */\n    this.assets = {};\n    /** @type {WebpackError[]} */\n    this.errors = [];\n    /** @type {WebpackError[]} */\n    this.warnings = [];\n    /** @type {Compilation[]} */\n    this.children = [];\n    /** @type {Map<DepConstructor, ModuleFactory>} */\n    this.dependencyFactories = new Map();\n    /** @type {Map<DepConstructor, DependencyTemplate>} */\n    this.dependencyTemplates = new Map();\n    // TODO refactor this in webpack 5 to a custom DependencyTemplates class with a hash property\n    // @ts-ignore\n    this.dependencyTemplates.set(\"hash\", \"\");\n    this.childrenCounters = {};\n    /** @type {Set<number|string>} */\n    this.usedChunkIds = null;\n    /** @type {Set<number>} */\n    this.usedModuleIds = null;\n    /** @type {Map<string, number>=} */\n    this.fileTimestamps = undefined;\n    /** @type {Map<string, number>=} */\n    this.contextTimestamps = undefined;\n    /** @type {Set<string>=} */\n    this.compilationDependencies = undefined;\n    /** @private @type {Map<Module, Callback[]>} */\n    this._buildingModules = new Map();\n    /** @private @type {Map<Module, Callback[]>} */\n    this._rebuildingModules = new Map();\n    /** @type {Set<string>} */\n    this.emittedAssets = new Set();\n  }\n  getStats() {\n    return new Stats(this);\n  }\n\n  /**\n   * @typedef {Object} AddModuleResult\n   * @property {Module} module the added or existing module\n   * @property {boolean} issuer was this the first request for this module\n   * @property {boolean} build should the module be build\n   * @property {boolean} dependencies should dependencies be walked\n   */\n\n  /**\n   * @param {Module} module module to be added that was created\n   * @param {any=} cacheGroup cacheGroup it is apart of\n   * @returns {AddModuleResult} returns meta about whether or not the module had built\n   * had an issuer, or any dependnecies\n   */\n  addModule(module, cacheGroup) {\n    const identifier = module.identifier();\n    const alreadyAddedModule = this._modules.get(identifier);\n    if (alreadyAddedModule) {\n      return {\n        module: alreadyAddedModule,\n        issuer: false,\n        build: false,\n        dependencies: false\n      };\n    }\n    const cacheName = (cacheGroup || \"m\") + identifier;\n    if (this.cache && this.cache[cacheName]) {\n      const cacheModule = this.cache[cacheName];\n      if (typeof cacheModule.updateCacheModule === \"function\") {\n        cacheModule.updateCacheModule(module);\n      }\n      let rebuild = true;\n      if (this.fileTimestamps && this.contextTimestamps) {\n        rebuild = cacheModule.needRebuild(this.fileTimestamps, this.contextTimestamps);\n      }\n      if (!rebuild) {\n        cacheModule.disconnect();\n        this._modules.set(identifier, cacheModule);\n        this.modules.push(cacheModule);\n        for (const err of cacheModule.errors) {\n          this.errors.push(err);\n        }\n        for (const err of cacheModule.warnings) {\n          this.warnings.push(err);\n        }\n        return {\n          module: cacheModule,\n          issuer: true,\n          build: false,\n          dependencies: true\n        };\n      }\n      cacheModule.unbuild();\n      module = cacheModule;\n    }\n    this._modules.set(identifier, module);\n    if (this.cache) {\n      this.cache[cacheName] = module;\n    }\n    this.modules.push(module);\n    return {\n      module: module,\n      issuer: true,\n      build: true,\n      dependencies: true\n    };\n  }\n\n  /**\n   * Fetches a module from a compilation by its identifier\n   * @param {Module} module the module provided\n   * @returns {Module} the module requested\n   */\n  getModule(module) {\n    const identifier = module.identifier();\n    return this._modules.get(identifier);\n  }\n\n  /**\n   * Attempts to search for a module by its identifier\n   * @param {string} identifier identifier (usually path) for module\n   * @returns {Module|undefined} attempt to search for module and return it, else undefined\n   */\n  findModule(identifier) {\n    return this._modules.get(identifier);\n  }\n\n  /**\n   * @param {Module} module module with its callback list\n   * @param {Callback} callback the callback function\n   * @returns {void}\n   */\n  waitForBuildingFinished(module, callback) {\n    let callbackList = this._buildingModules.get(module);\n    if (callbackList) {\n      callbackList.push(() => callback());\n    } else {\n      process.nextTick(callback);\n    }\n  }\n\n  /**\n   * Builds the module object\n   *\n   * @param {Module} module module to be built\n   * @param {boolean} optional optional flag\n   * @param {Module=} origin origin module this module build was requested from\n   * @param {Dependency[]=} dependencies optional dependencies from the module to be built\n   * @param {TODO} thisCallback the callback\n   * @returns {TODO} returns the callback function with results\n   */\n  buildModule(module, optional, origin, dependencies, thisCallback) {\n    let callbackList = this._buildingModules.get(module);\n    if (callbackList) {\n      callbackList.push(thisCallback);\n      return;\n    }\n    this._buildingModules.set(module, callbackList = [thisCallback]);\n    const callback = err => {\n      this._buildingModules.delete(module);\n      for (const cb of callbackList) {\n        cb(err);\n      }\n    };\n    this.hooks.buildModule.call(module);\n    module.build(this.options, this, this.resolverFactory.get(\"normal\", module.resolveOptions), this.inputFileSystem, error => {\n      const errors = module.errors;\n      for (let indexError = 0; indexError < errors.length; indexError++) {\n        const err = errors[indexError];\n        err.origin = origin;\n        err.dependencies = dependencies;\n        if (optional) {\n          this.warnings.push(err);\n        } else {\n          this.errors.push(err);\n        }\n      }\n      const warnings = module.warnings;\n      for (let indexWarning = 0; indexWarning < warnings.length; indexWarning++) {\n        const war = warnings[indexWarning];\n        war.origin = origin;\n        war.dependencies = dependencies;\n        this.warnings.push(war);\n      }\n      const originalMap = module.dependencies.reduce((map, v, i) => {\n        map.set(v, i);\n        return map;\n      }, new Map());\n      module.dependencies.sort((a, b) => {\n        const cmp = compareLocations(a.loc, b.loc);\n        if (cmp) return cmp;\n        return originalMap.get(a) - originalMap.get(b);\n      });\n      if (error) {\n        this.hooks.failedModule.call(module, error);\n        return callback(error);\n      }\n      this.hooks.succeedModule.call(module);\n      return callback();\n    });\n  }\n\n  /**\n   * @param {Module} module to be processed for deps\n   * @param {ModuleCallback} callback callback to be triggered\n   * @returns {void}\n   */\n  processModuleDependencies(module, callback) {\n    const dependencies = new Map();\n    const addDependency = dep => {\n      const resourceIdent = dep.getResourceIdentifier();\n      if (resourceIdent) {\n        const factory = this.dependencyFactories.get(dep.constructor);\n        if (factory === undefined) {\n          throw new Error(`No module factory available for dependency type: ${dep.constructor.name}`);\n        }\n        let innerMap = dependencies.get(factory);\n        if (innerMap === undefined) {\n          dependencies.set(factory, innerMap = new Map());\n        }\n        let list = innerMap.get(resourceIdent);\n        if (list === undefined) innerMap.set(resourceIdent, list = []);\n        list.push(dep);\n      }\n    };\n    const addDependenciesBlock = block => {\n      if (block.dependencies) {\n        iterationOfArrayCallback(block.dependencies, addDependency);\n      }\n      if (block.blocks) {\n        iterationOfArrayCallback(block.blocks, addDependenciesBlock);\n      }\n      if (block.variables) {\n        iterationBlockVariable(block.variables, addDependency);\n      }\n    };\n    try {\n      addDependenciesBlock(module);\n    } catch (e) {\n      callback(e);\n    }\n    const sortedDependencies = [];\n    for (const pair1 of dependencies) {\n      for (const pair2 of pair1[1]) {\n        sortedDependencies.push({\n          factory: pair1[0],\n          dependencies: pair2[1]\n        });\n      }\n    }\n    this.addModuleDependencies(module, sortedDependencies, this.bail, null, true, callback);\n  }\n\n  /**\n   * @param {Module} module module to add deps to\n   * @param {SortedDependency[]} dependencies set of sorted dependencies to iterate through\n   * @param {(boolean|null)=} bail whether to bail or not\n   * @param {TODO} cacheGroup optional cacheGroup\n   * @param {boolean} recursive whether it is recursive traversal\n   * @param {function} callback callback for when dependencies are finished being added\n   * @returns {void}\n   */\n  addModuleDependencies(module, dependencies, bail, cacheGroup, recursive, callback) {\n    const start = this.profile && Date.now();\n    const currentProfile = this.profile && {};\n    asyncLib.forEach(dependencies, (item, callback) => {\n      const dependencies = item.dependencies;\n      const errorAndCallback = err => {\n        err.origin = module;\n        err.dependencies = dependencies;\n        this.errors.push(err);\n        if (bail) {\n          callback(err);\n        } else {\n          callback();\n        }\n      };\n      const warningAndCallback = err => {\n        err.origin = module;\n        this.warnings.push(err);\n        callback();\n      };\n      const semaphore = this.semaphore;\n      semaphore.acquire(() => {\n        const factory = item.factory;\n        factory.create({\n          contextInfo: {\n            issuer: module.nameForCondition && module.nameForCondition(),\n            compiler: this.compiler.name\n          },\n          resolveOptions: module.resolveOptions,\n          context: module.context,\n          dependencies: dependencies\n        }, (err, dependentModule) => {\n          let afterFactory;\n          const isOptional = () => {\n            return dependencies.every(d => d.optional);\n          };\n          const errorOrWarningAndCallback = err => {\n            if (isOptional()) {\n              return warningAndCallback(err);\n            } else {\n              return errorAndCallback(err);\n            }\n          };\n          if (err) {\n            semaphore.release();\n            return errorOrWarningAndCallback(new ModuleNotFoundError(module, err));\n          }\n          if (!dependentModule) {\n            semaphore.release();\n            return process.nextTick(callback);\n          }\n          if (currentProfile) {\n            afterFactory = Date.now();\n            currentProfile.factory = afterFactory - start;\n          }\n          const iterationDependencies = depend => {\n            for (let index = 0; index < depend.length; index++) {\n              const dep = depend[index];\n              dep.module = dependentModule;\n              dependentModule.addReason(module, dep);\n            }\n          };\n          const addModuleResult = this.addModule(dependentModule, cacheGroup);\n          dependentModule = addModuleResult.module;\n          iterationDependencies(dependencies);\n          const afterBuild = () => {\n            if (currentProfile) {\n              const afterBuilding = Date.now();\n              currentProfile.building = afterBuilding - afterFactory;\n            }\n            if (recursive && addModuleResult.dependencies) {\n              this.processModuleDependencies(dependentModule, callback);\n            } else {\n              return callback();\n            }\n          };\n          if (addModuleResult.issuer) {\n            if (currentProfile) {\n              dependentModule.profile = currentProfile;\n            }\n            dependentModule.issuer = module;\n          } else {\n            if (this.profile) {\n              if (module.profile) {\n                const time = Date.now() - start;\n                if (!module.profile.dependencies || time > module.profile.dependencies) {\n                  module.profile.dependencies = time;\n                }\n              }\n            }\n          }\n          if (addModuleResult.build) {\n            this.buildModule(dependentModule, isOptional(), module, dependencies, err => {\n              if (err) {\n                semaphore.release();\n                return errorOrWarningAndCallback(err);\n              }\n              if (currentProfile) {\n                const afterBuilding = Date.now();\n                currentProfile.building = afterBuilding - afterFactory;\n              }\n              semaphore.release();\n              afterBuild();\n            });\n          } else {\n            semaphore.release();\n            this.waitForBuildingFinished(dependentModule, afterBuild);\n          }\n        });\n      });\n    }, err => {\n      // In V8, the Error objects keep a reference to the functions on the stack. These warnings &\n      // errors are created inside closures that keep a reference to the Compilation, so errors are\n      // leaking the Compilation object.\n\n      if (err) {\n        // eslint-disable-next-line no-self-assign\n        err.stack = err.stack;\n        return callback(err);\n      }\n      return process.nextTick(callback);\n    });\n  }\n\n  /**\n   *\n   * @param {string} context context string path\n   * @param {Dependency} dependency dependency used to create Module chain\n   * @param {OnModuleCallback} onModule function invoked on modules creation\n   * @param {ModuleChainCallback} callback callback for when module chain is complete\n   * @returns {void} will throw if dependency instance is not a valid Dependency\n   */\n  _addModuleChain(context, dependency, onModule, callback) {\n    const start = this.profile && Date.now();\n    const currentProfile = this.profile && {};\n    const errorAndCallback = this.bail ? err => {\n      callback(err);\n    } : err => {\n      err.dependencies = [dependency];\n      this.errors.push(err);\n      callback();\n    };\n    if (typeof dependency !== \"object\" || dependency === null || !dependency.constructor) {\n      throw new Error(\"Parameter 'dependency' must be a Dependency\");\n    }\n    const Dep = /** @type {DepConstructor} */dependency.constructor;\n    const moduleFactory = this.dependencyFactories.get(Dep);\n    if (!moduleFactory) {\n      throw new Error(`No dependency factory available for this dependency type: ${dependency.constructor.name}`);\n    }\n    this.semaphore.acquire(() => {\n      moduleFactory.create({\n        contextInfo: {\n          issuer: \"\",\n          compiler: this.compiler.name\n        },\n        context: context,\n        dependencies: [dependency]\n      }, (err, module) => {\n        if (err) {\n          this.semaphore.release();\n          return errorAndCallback(new EntryModuleNotFoundError(err));\n        }\n        let afterFactory;\n        if (currentProfile) {\n          afterFactory = Date.now();\n          currentProfile.factory = afterFactory - start;\n        }\n        const addModuleResult = this.addModule(module);\n        module = addModuleResult.module;\n        onModule(module);\n        dependency.module = module;\n        module.addReason(null, dependency);\n        const afterBuild = () => {\n          if (currentProfile) {\n            const afterBuilding = Date.now();\n            currentProfile.building = afterBuilding - afterFactory;\n          }\n          if (addModuleResult.dependencies) {\n            this.processModuleDependencies(module, err => {\n              if (err) return callback(err);\n              callback(null, module);\n            });\n          } else {\n            return callback(null, module);\n          }\n        };\n        if (addModuleResult.issuer) {\n          if (currentProfile) {\n            module.profile = currentProfile;\n          }\n        }\n        if (addModuleResult.build) {\n          this.buildModule(module, false, null, null, err => {\n            if (err) {\n              this.semaphore.release();\n              return errorAndCallback(err);\n            }\n            if (currentProfile) {\n              const afterBuilding = Date.now();\n              currentProfile.building = afterBuilding - afterFactory;\n            }\n            this.semaphore.release();\n            afterBuild();\n          });\n        } else {\n          this.semaphore.release();\n          this.waitForBuildingFinished(module, afterBuild);\n        }\n      });\n    });\n  }\n\n  /**\n   *\n   * @param {string} context context path for entry\n   * @param {Dependency} entry entry dependency being created\n   * @param {string} name name of entry\n   * @param {ModuleCallback} callback callback function\n   * @returns {void} returns\n   */\n  addEntry(context, entry, name, callback) {\n    this.hooks.addEntry.call(entry, name);\n    const slot = {\n      name: name,\n      // TODO webpack 5 remove `request`\n      request: null,\n      module: null\n    };\n    if (entry instanceof ModuleDependency) {\n      slot.request = entry.request;\n    }\n\n    // TODO webpack 5: merge modules instead when multiple entry modules are supported\n    const idx = this._preparedEntrypoints.findIndex(slot => slot.name === name);\n    if (idx >= 0) {\n      // Overwrite existing entrypoint\n      this._preparedEntrypoints[idx] = slot;\n    } else {\n      this._preparedEntrypoints.push(slot);\n    }\n    this._addModuleChain(context, entry, module => {\n      this.entries.push(module);\n    }, (err, module) => {\n      if (err) {\n        this.hooks.failedEntry.call(entry, name, err);\n        return callback(err);\n      }\n      if (module) {\n        slot.module = module;\n      } else {\n        const idx = this._preparedEntrypoints.indexOf(slot);\n        if (idx >= 0) {\n          this._preparedEntrypoints.splice(idx, 1);\n        }\n      }\n      this.hooks.succeedEntry.call(entry, name, module);\n      return callback(null, module);\n    });\n  }\n\n  /**\n   * @param {string} context context path string\n   * @param {Dependency} dependency dep used to create module\n   * @param {ModuleCallback} callback module callback sending module up a level\n   * @returns {void}\n   */\n  prefetch(context, dependency, callback) {\n    this._addModuleChain(context, dependency, module => {\n      module.prefetched = true;\n    }, callback);\n  }\n\n  /**\n   * @param {Module} module module to be rebuilt\n   * @param {Callback} thisCallback callback when module finishes rebuilding\n   * @returns {void}\n   */\n  rebuildModule(module, thisCallback) {\n    let callbackList = this._rebuildingModules.get(module);\n    if (callbackList) {\n      callbackList.push(thisCallback);\n      return;\n    }\n    this._rebuildingModules.set(module, callbackList = [thisCallback]);\n    const callback = err => {\n      this._rebuildingModules.delete(module);\n      for (const cb of callbackList) {\n        cb(err);\n      }\n    };\n    this.hooks.rebuildModule.call(module);\n    const oldDependencies = module.dependencies.slice();\n    const oldVariables = module.variables.slice();\n    const oldBlocks = module.blocks.slice();\n    module.unbuild();\n    this.buildModule(module, false, module, null, err => {\n      if (err) {\n        this.hooks.finishRebuildingModule.call(module);\n        return callback(err);\n      }\n      this.processModuleDependencies(module, err => {\n        if (err) return callback(err);\n        this.removeReasonsOfDependencyBlock(module, {\n          dependencies: oldDependencies,\n          variables: oldVariables,\n          blocks: oldBlocks\n        });\n        this.hooks.finishRebuildingModule.call(module);\n        callback();\n      });\n    });\n  }\n  finish() {\n    const modules = this.modules;\n    this.hooks.finishModules.call(modules);\n    for (let index = 0; index < modules.length; index++) {\n      const module = modules[index];\n      this.reportDependencyErrorsAndWarnings(module, [module]);\n    }\n  }\n  unseal() {\n    this.hooks.unseal.call();\n    this.chunks.length = 0;\n    this.chunkGroups.length = 0;\n    this.namedChunks.clear();\n    this.namedChunkGroups.clear();\n    this.additionalChunkAssets.length = 0;\n    this.assets = {};\n    for (const module of this.modules) {\n      module.unseal();\n    }\n  }\n\n  /**\n   * @param {Callback} callback signals when the seal method is finishes\n   * @returns {void}\n   */\n  seal(callback) {\n    this.hooks.seal.call();\n    while (this.hooks.optimizeDependenciesBasic.call(this.modules) || this.hooks.optimizeDependencies.call(this.modules) || this.hooks.optimizeDependenciesAdvanced.call(this.modules)) {\n      /* empty */\n    }\n    this.hooks.afterOptimizeDependencies.call(this.modules);\n    this.hooks.beforeChunks.call();\n    for (const preparedEntrypoint of this._preparedEntrypoints) {\n      const module = preparedEntrypoint.module;\n      const name = preparedEntrypoint.name;\n      const chunk = this.addChunk(name);\n      const entrypoint = new Entrypoint(name);\n      entrypoint.setRuntimeChunk(chunk);\n      entrypoint.addOrigin(null, name, preparedEntrypoint.request);\n      this.namedChunkGroups.set(name, entrypoint);\n      this.entrypoints.set(name, entrypoint);\n      this.chunkGroups.push(entrypoint);\n      GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);\n      GraphHelpers.connectChunkAndModule(chunk, module);\n      chunk.entryModule = module;\n      chunk.name = name;\n      this.assignDepth(module);\n    }\n    this.processDependenciesBlocksForChunkGroups(this.chunkGroups.slice());\n    this.sortModules(this.modules);\n    this.hooks.afterChunks.call(this.chunks);\n    this.hooks.optimize.call();\n    while (this.hooks.optimizeModulesBasic.call(this.modules) || this.hooks.optimizeModules.call(this.modules) || this.hooks.optimizeModulesAdvanced.call(this.modules)) {\n      /* empty */\n    }\n    this.hooks.afterOptimizeModules.call(this.modules);\n    while (this.hooks.optimizeChunksBasic.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunks.call(this.chunks, this.chunkGroups) || this.hooks.optimizeChunksAdvanced.call(this.chunks, this.chunkGroups)) {\n      /* empty */\n    }\n    this.hooks.afterOptimizeChunks.call(this.chunks, this.chunkGroups);\n    this.hooks.optimizeTree.callAsync(this.chunks, this.modules, err => {\n      if (err) {\n        return callback(err);\n      }\n      this.hooks.afterOptimizeTree.call(this.chunks, this.modules);\n      while (this.hooks.optimizeChunkModulesBasic.call(this.chunks, this.modules) || this.hooks.optimizeChunkModules.call(this.chunks, this.modules) || this.hooks.optimizeChunkModulesAdvanced.call(this.chunks, this.modules)) {\n        /* empty */\n      }\n      this.hooks.afterOptimizeChunkModules.call(this.chunks, this.modules);\n      const shouldRecord = this.hooks.shouldRecord.call() !== false;\n      this.hooks.reviveModules.call(this.modules, this.records);\n      this.hooks.optimizeModuleOrder.call(this.modules);\n      this.hooks.advancedOptimizeModuleOrder.call(this.modules);\n      this.hooks.beforeModuleIds.call(this.modules);\n      this.hooks.moduleIds.call(this.modules);\n      this.applyModuleIds();\n      this.hooks.optimizeModuleIds.call(this.modules);\n      this.hooks.afterOptimizeModuleIds.call(this.modules);\n      this.sortItemsWithModuleIds();\n      this.hooks.reviveChunks.call(this.chunks, this.records);\n      this.hooks.optimizeChunkOrder.call(this.chunks);\n      this.hooks.beforeChunkIds.call(this.chunks);\n      this.applyChunkIds();\n      this.hooks.optimizeChunkIds.call(this.chunks);\n      this.hooks.afterOptimizeChunkIds.call(this.chunks);\n      this.sortItemsWithChunkIds();\n      if (shouldRecord) {\n        this.hooks.recordModules.call(this.modules, this.records);\n        this.hooks.recordChunks.call(this.chunks, this.records);\n      }\n      this.hooks.beforeHash.call();\n      this.createHash();\n      this.hooks.afterHash.call();\n      if (shouldRecord) {\n        this.hooks.recordHash.call(this.records);\n      }\n      this.hooks.beforeModuleAssets.call();\n      this.createModuleAssets();\n      if (this.hooks.shouldGenerateChunkAssets.call() !== false) {\n        this.hooks.beforeChunkAssets.call();\n        this.createChunkAssets();\n      }\n      this.hooks.additionalChunkAssets.call(this.chunks);\n      this.summarizeDependencies();\n      if (shouldRecord) {\n        this.hooks.record.call(this, this.records);\n      }\n      this.hooks.additionalAssets.callAsync(err => {\n        if (err) {\n          return callback(err);\n        }\n        this.hooks.optimizeChunkAssets.callAsync(this.chunks, err => {\n          if (err) {\n            return callback(err);\n          }\n          this.hooks.afterOptimizeChunkAssets.call(this.chunks);\n          this.hooks.optimizeAssets.callAsync(this.assets, err => {\n            if (err) {\n              return callback(err);\n            }\n            this.hooks.afterOptimizeAssets.call(this.assets);\n            if (this.hooks.needAdditionalSeal.call()) {\n              this.unseal();\n              return this.seal(callback);\n            }\n            return this.hooks.afterSeal.callAsync(callback);\n          });\n        });\n      });\n    });\n  }\n\n  /**\n   * @param {Module[]} modules the modules array on compilation to perform the sort for\n   * @returns {void}\n   */\n  sortModules(modules) {\n    // TODO webpack 5: this should only be enabled when `moduleIds: \"natural\"`\n    // TODO move it into a plugin (NaturalModuleIdsPlugin) and use this in WebpackOptionsApply\n    // TODO remove this method\n    modules.sort(byIndexOrIdentifier);\n  }\n\n  /**\n   * @param {Module} module moulde to report from\n   * @param {DependenciesBlock[]} blocks blocks to report from\n   * @returns {void}\n   */\n  reportDependencyErrorsAndWarnings(module, blocks) {\n    for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n      const block = blocks[indexBlock];\n      const dependencies = block.dependencies;\n      for (let indexDep = 0; indexDep < dependencies.length; indexDep++) {\n        const d = dependencies[indexDep];\n        const warnings = d.getWarnings();\n        if (warnings) {\n          for (let indexWar = 0; indexWar < warnings.length; indexWar++) {\n            const w = warnings[indexWar];\n            const warning = new ModuleDependencyWarning(module, w, d.loc);\n            this.warnings.push(warning);\n          }\n        }\n        const errors = d.getErrors();\n        if (errors) {\n          for (let indexErr = 0; indexErr < errors.length; indexErr++) {\n            const e = errors[indexErr];\n            const error = new ModuleDependencyError(module, e, d.loc);\n            this.errors.push(error);\n          }\n        }\n      }\n      this.reportDependencyErrorsAndWarnings(module, block.blocks);\n    }\n  }\n\n  /**\n   * @param {TODO} groupOptions options for the chunk group\n   * @param {Module} module the module the references the chunk group\n   * @param {DependencyLocation} loc the location from with the chunk group is referenced (inside of module)\n   * @param {string} request the request from which the the chunk group is referenced\n   * @returns {ChunkGroup} the new or existing chunk group\n   */\n  addChunkInGroup(groupOptions, module, loc, request) {\n    if (typeof groupOptions === \"string\") {\n      groupOptions = {\n        name: groupOptions\n      };\n    }\n    const name = groupOptions.name;\n    if (name) {\n      const chunkGroup = this.namedChunkGroups.get(name);\n      if (chunkGroup !== undefined) {\n        chunkGroup.addOptions(groupOptions);\n        if (module) {\n          chunkGroup.addOrigin(module, loc, request);\n        }\n        return chunkGroup;\n      }\n    }\n    const chunkGroup = new ChunkGroup(groupOptions);\n    if (module) chunkGroup.addOrigin(module, loc, request);\n    const chunk = this.addChunk(name);\n    GraphHelpers.connectChunkGroupAndChunk(chunkGroup, chunk);\n    this.chunkGroups.push(chunkGroup);\n    if (name) {\n      this.namedChunkGroups.set(name, chunkGroup);\n    }\n    return chunkGroup;\n  }\n\n  /**\n   * This method first looks to see if a name is provided for a new chunk,\n   * and first looks to see if any named chunks already exist and reuse that chunk instead.\n   *\n   * @param {string=} name optional chunk name to be provided\n   * @returns {Chunk} create a chunk (invoked during seal event)\n   */\n  addChunk(name) {\n    if (name) {\n      const chunk = this.namedChunks.get(name);\n      if (chunk !== undefined) {\n        return chunk;\n      }\n    }\n    const chunk = new Chunk(name);\n    this.chunks.push(chunk);\n    if (name) {\n      this.namedChunks.set(name, chunk);\n    }\n    return chunk;\n  }\n\n  /**\n   * @param {Module} module module to assign depth\n   * @returns {void}\n   */\n  assignDepth(module) {\n    const queue = new Set([module]);\n    let depth;\n    module.depth = 0;\n\n    /**\n     * @param {Module} module module for processeing\n     * @returns {void}\n     */\n    const enqueueJob = module => {\n      const d = module.depth;\n      if (typeof d === \"number\" && d <= depth) return;\n      queue.add(module);\n      module.depth = depth;\n    };\n\n    /**\n     * @param {Dependency} dependency dependency to assign depth to\n     * @returns {void}\n     */\n    const assignDepthToDependency = dependency => {\n      if (dependency.module) {\n        enqueueJob(dependency.module);\n      }\n    };\n\n    /**\n     * @param {DependenciesBlock} block block to assign depth to\n     * @returns {void}\n     */\n    const assignDepthToDependencyBlock = block => {\n      if (block.variables) {\n        iterationBlockVariable(block.variables, assignDepthToDependency);\n      }\n      if (block.dependencies) {\n        iterationOfArrayCallback(block.dependencies, assignDepthToDependency);\n      }\n      if (block.blocks) {\n        iterationOfArrayCallback(block.blocks, assignDepthToDependencyBlock);\n      }\n    };\n    for (module of queue) {\n      queue.delete(module);\n      depth = module.depth;\n      depth++;\n      assignDepthToDependencyBlock(module);\n    }\n  }\n\n  /**\n   * @param {Module} module the module containing the dependency\n   * @param {Dependency} dependency the dependency\n   * @returns {DependencyReference} a reference for the dependency\n   */\n  getDependencyReference(module, dependency) {\n    // TODO remove dep.getReference existence check in webpack 5\n    if (typeof dependency.getReference !== \"function\") return null;\n    const ref = dependency.getReference();\n    if (!ref) return null;\n    return this.hooks.dependencyReference.call(ref, dependency, module);\n  }\n\n  /**\n   * This method creates the Chunk graph from the Module graph\n   * @private\n   * @param {TODO[]} inputChunkGroups chunk groups which are processed\n   * @returns {void}\n   */\n  processDependenciesBlocksForChunkGroups(inputChunkGroups) {\n    // Process is splitting into two parts:\n    // Part one traverse the module graph and builds a very basic chunks graph\n    //   in chunkDependencies.\n    // Part two traverse every possible way through the basic chunk graph and\n    //   tracks the available modules. While traversing it connects chunks with\n    //   eachother and Blocks with Chunks. It stops traversing when all modules\n    //   for a chunk are already available. So it doesn't connect unneeded chunks.\n\n    /** @type {Map<ChunkGroup, {block: AsyncDependenciesBlock, chunkGroup: ChunkGroup, couldBeFiltered: boolean}[]>} */\n    const chunkDependencies = new Map();\n    const allCreatedChunkGroups = new Set();\n\n    // PREPARE\n    /** @type {Map<DependenciesBlock, { modules: Module[], blocks: AsyncDependenciesBlock[]}>} */\n    const blockInfoMap = new Map();\n\n    /**\n     * @param {Dependency} d dependency to iterate over\n     * @returns {void}\n     */\n    const iteratorDependency = d => {\n      // We skip Dependencies without Reference\n      const ref = this.getDependencyReference(currentModule, d);\n      if (!ref) {\n        return;\n      }\n      // We skip Dependencies without Module pointer\n      const refModule = ref.module;\n      if (!refModule) {\n        return;\n      }\n      // We skip weak Dependencies\n      if (ref.weak) {\n        return;\n      }\n      blockInfoModules.add(refModule);\n    };\n\n    /**\n     * @param {AsyncDependenciesBlock} b blocks to prepare\n     * @returns {void}\n     */\n    const iteratorBlockPrepare = b => {\n      blockInfoBlocks.push(b);\n      blockQueue.push(b);\n    };\n\n    /** @type {Module} */\n    let currentModule;\n    /** @type {DependenciesBlock} */\n    let block;\n    /** @type {DependenciesBlock[]} */\n    let blockQueue;\n    /** @type {Set<Module>} */\n    let blockInfoModules;\n    /** @type {AsyncDependenciesBlock[]} */\n    let blockInfoBlocks;\n    for (const module of this.modules) {\n      blockQueue = [module];\n      currentModule = module;\n      while (blockQueue.length > 0) {\n        block = blockQueue.pop();\n        blockInfoModules = new Set();\n        blockInfoBlocks = [];\n        if (block.variables) {\n          iterationBlockVariable(block.variables, iteratorDependency);\n        }\n        if (block.dependencies) {\n          iterationOfArrayCallback(block.dependencies, iteratorDependency);\n        }\n        if (block.blocks) {\n          iterationOfArrayCallback(block.blocks, iteratorBlockPrepare);\n        }\n        const blockInfo = {\n          modules: Array.from(blockInfoModules),\n          blocks: blockInfoBlocks\n        };\n        blockInfoMap.set(block, blockInfo);\n      }\n    }\n\n    // PART ONE\n\n    /** @type {Map<ChunkGroup, { index: number, index2: number }>} */\n    const chunkGroupCounters = new Map();\n    for (const chunkGroup of inputChunkGroups) {\n      chunkGroupCounters.set(chunkGroup, {\n        index: 0,\n        index2: 0\n      });\n    }\n    let nextFreeModuleIndex = 0;\n    let nextFreeModuleIndex2 = 0;\n\n    /** @type {Map<DependenciesBlock, ChunkGroup>} */\n    const blockChunkGroups = new Map();\n\n    /** @type {Set<DependenciesBlock>} */\n    const blocksWithNestedBlocks = new Set();\n    const ADD_AND_ENTER_MODULE = 0;\n    const ENTER_MODULE = 1;\n    const PROCESS_BLOCK = 2;\n    const LEAVE_MODULE = 3;\n\n    /**\n     * @typedef {Object} QueueItem\n     * @property {number} action\n     * @property {DependenciesBlock} block\n     * @property {Module} module\n     * @property {Chunk} chunk\n     * @property {ChunkGroup} chunkGroup\n     */\n\n    /**\n     * @param {ChunkGroup} chunkGroup chunk group\n     * @returns {QueueItem} queue item\n     */\n    const chunkGroupToQueueItem = chunkGroup => ({\n      action: ENTER_MODULE,\n      block: chunkGroup.chunks[0].entryModule,\n      module: chunkGroup.chunks[0].entryModule,\n      chunk: chunkGroup.chunks[0],\n      chunkGroup\n    });\n\n    // Start with the provided modules/chunks\n    /** @type {QueueItem[]} */\n    let queue = inputChunkGroups.map(chunkGroupToQueueItem).reverse();\n    /** @type {QueueItem[]} */\n    let queueDelayed = [];\n\n    /** @type {Module} */\n    let module;\n    /** @type {Chunk} */\n    let chunk;\n    /** @type {ChunkGroup} */\n    let chunkGroup;\n\n    // For each async Block in graph\n    /**\n     * @param {AsyncDependenciesBlock} b iterating over each Async DepBlock\n     * @returns {void}\n     */\n    const iteratorBlock = b => {\n      // 1. We create a chunk for this Block\n      // but only once (blockChunkGroups map)\n      let c = blockChunkGroups.get(b);\n      if (c === undefined) {\n        c = this.namedChunkGroups.get(b.chunkName);\n        if (c && c.isInitial()) {\n          this.errors.push(new AsyncDependencyToInitialChunkError(b.chunkName, module, b.loc));\n          c = chunkGroup;\n        } else {\n          c = this.addChunkInGroup(b.groupOptions || b.chunkName, module, b.loc, b.request);\n          chunkGroupCounters.set(c, {\n            index: 0,\n            index2: 0\n          });\n          blockChunkGroups.set(b, c);\n          allCreatedChunkGroups.add(c);\n        }\n      } else {\n        // TODO webpack 5 remove addOptions check\n        if (c.addOptions) c.addOptions(b.groupOptions);\n        c.addOrigin(module, b.loc, b.request);\n      }\n\n      // 2. We store the Block+Chunk mapping as dependency for the chunk\n      let deps = chunkDependencies.get(chunkGroup);\n      if (!deps) chunkDependencies.set(chunkGroup, deps = []);\n      deps.push({\n        block: b,\n        chunkGroup: c,\n        couldBeFiltered: true\n      });\n\n      // 3. We enqueue the DependenciesBlock for traversal\n      queueDelayed.push({\n        action: PROCESS_BLOCK,\n        block: b,\n        module: module,\n        chunk: c.chunks[0],\n        chunkGroup: c\n      });\n    };\n\n    // Iterative traversal of the Module graph\n    // Recursive would be simpler to write but could result in Stack Overflows\n    while (queue.length) {\n      while (queue.length) {\n        const queueItem = queue.pop();\n        module = queueItem.module;\n        block = queueItem.block;\n        chunk = queueItem.chunk;\n        chunkGroup = queueItem.chunkGroup;\n        switch (queueItem.action) {\n          case ADD_AND_ENTER_MODULE:\n            {\n              // We connect Module and Chunk when not already done\n              if (chunk.addModule(module)) {\n                module.addChunk(chunk);\n              } else {\n                // already connected, skip it\n                break;\n              }\n            }\n          // fallthrough\n          case ENTER_MODULE:\n            {\n              if (chunkGroup !== undefined) {\n                const index = chunkGroup.getModuleIndex(module);\n                if (index === undefined) {\n                  chunkGroup.setModuleIndex(module, chunkGroupCounters.get(chunkGroup).index++);\n                }\n              }\n              if (module.index === null) {\n                module.index = nextFreeModuleIndex++;\n              }\n              queue.push({\n                action: LEAVE_MODULE,\n                block,\n                module,\n                chunk,\n                chunkGroup\n              });\n            }\n          // fallthrough\n          case PROCESS_BLOCK:\n            {\n              // get prepared block info\n              const blockInfo = blockInfoMap.get(block);\n\n              // Traverse all referenced modules\n              for (let i = blockInfo.modules.length - 1; i >= 0; i--) {\n                const refModule = blockInfo.modules[i];\n                if (chunk.containsModule(refModule)) {\n                  // skip early if already connected\n                  continue;\n                }\n                // enqueue the add and enter to enter in the correct order\n                // this is relevant with circular dependencies\n                queue.push({\n                  action: ADD_AND_ENTER_MODULE,\n                  block: refModule,\n                  module: refModule,\n                  chunk,\n                  chunkGroup\n                });\n              }\n\n              // Traverse all Blocks\n              iterationOfArrayCallback(blockInfo.blocks, iteratorBlock);\n              if (blockInfo.blocks.length > 0 && module !== block) {\n                blocksWithNestedBlocks.add(block);\n              }\n              break;\n            }\n          case LEAVE_MODULE:\n            {\n              if (chunkGroup !== undefined) {\n                const index = chunkGroup.getModuleIndex2(module);\n                if (index === undefined) {\n                  chunkGroup.setModuleIndex2(module, chunkGroupCounters.get(chunkGroup).index2++);\n                }\n              }\n              if (module.index2 === null) {\n                module.index2 = nextFreeModuleIndex2++;\n              }\n              break;\n            }\n        }\n      }\n      const tempQueue = queue;\n      queue = queueDelayed.reverse();\n      queueDelayed = tempQueue;\n    }\n\n    // PART TWO\n    /** @type {Set<Module>} */\n    let newAvailableModules;\n\n    /**\n     * @typedef {Object} ChunkGroupInfo\n     * @property {Set<Module>} minAvailableModules current minimal set of modules available at this point\n     * @property {Set<Module>[]} availableModulesToBeMerged enqueued updates to the minimal set of available modules\n     */\n\n    /** @type {Map<ChunkGroup, ChunkGroupInfo>} */\n    const chunkGroupInfoMap = new Map();\n\n    /** @type {Queue<ChunkGroup>} */\n    const queue2 = new Queue(inputChunkGroups);\n    for (const chunkGroup of inputChunkGroups) {\n      chunkGroupInfoMap.set(chunkGroup, {\n        minAvailableModules: undefined,\n        availableModulesToBeMerged: [new Set()]\n      });\n    }\n\n    /**\n     * Helper function to check if all modules of a chunk are available\n     *\n     * @param {ChunkGroup} chunkGroup the chunkGroup to scan\n     * @param {Set<Module>} availableModules the comparitor set\n     * @returns {boolean} return true if all modules of a chunk are available\n     */\n    const areModulesAvailable = (chunkGroup, availableModules) => {\n      for (const chunk of chunkGroup.chunks) {\n        for (const module of chunk.modulesIterable) {\n          if (!availableModules.has(module)) return false;\n        }\n      }\n      return true;\n    };\n\n    // For each edge in the basic chunk graph\n    /**\n     * @param {TODO} dep the dependency used for filtering\n     * @returns {boolean} used to filter \"edges\" (aka Dependencies) that were pointing\n     * to modules that are already available. Also filters circular dependencies in the chunks graph\n     */\n    const filterFn = dep => {\n      const depChunkGroup = dep.chunkGroup;\n      if (!dep.couldBeFiltered) return true;\n      if (blocksWithNestedBlocks.has(dep.block)) return true;\n      if (areModulesAvailable(depChunkGroup, newAvailableModules)) {\n        return false; // break all modules are already available\n      }\n\n      dep.couldBeFiltered = false;\n      return true;\n    };\n\n    // Iterative traversing of the basic chunk graph\n    while (queue2.length) {\n      chunkGroup = queue2.dequeue();\n      const info = chunkGroupInfoMap.get(chunkGroup);\n      const availableModulesToBeMerged = info.availableModulesToBeMerged;\n      let minAvailableModules = info.minAvailableModules;\n\n      // 1. Get minimal available modules\n      // It doesn't make sense to traverse a chunk again with more available modules.\n      // This step calculates the minimal available modules and skips traversal when\n      // the list didn't shrink.\n      availableModulesToBeMerged.sort(bySetSize);\n      let changed = false;\n      for (const availableModules of availableModulesToBeMerged) {\n        if (minAvailableModules === undefined) {\n          minAvailableModules = new Set(availableModules);\n          info.minAvailableModules = minAvailableModules;\n          changed = true;\n        } else {\n          for (const m of minAvailableModules) {\n            if (!availableModules.has(m)) {\n              minAvailableModules.delete(m);\n              changed = true;\n            }\n          }\n        }\n      }\n      availableModulesToBeMerged.length = 0;\n      if (!changed) continue;\n\n      // 2. Get the edges at this point of the graph\n      const deps = chunkDependencies.get(chunkGroup);\n      if (!deps) continue;\n      if (deps.length === 0) continue;\n\n      // 3. Create a new Set of available modules at this points\n      newAvailableModules = new Set(minAvailableModules);\n      for (const chunk of chunkGroup.chunks) {\n        for (const m of chunk.modulesIterable) {\n          newAvailableModules.add(m);\n        }\n      }\n\n      // 4. Foreach remaining edge\n      const nextChunkGroups = new Set();\n      for (let i = 0; i < deps.length; i++) {\n        const dep = deps[i];\n\n        // Filter inline, rather than creating a new array from `.filter()`\n        if (!filterFn(dep)) {\n          continue;\n        }\n        const depChunkGroup = dep.chunkGroup;\n        const depBlock = dep.block;\n\n        // 5. Connect block with chunk\n        GraphHelpers.connectDependenciesBlockAndChunkGroup(depBlock, depChunkGroup);\n\n        // 6. Connect chunk with parent\n        GraphHelpers.connectChunkGroupParentAndChild(chunkGroup, depChunkGroup);\n        nextChunkGroups.add(depChunkGroup);\n      }\n\n      // 7. Enqueue further traversal\n      for (const nextChunkGroup of nextChunkGroups) {\n        let nextInfo = chunkGroupInfoMap.get(nextChunkGroup);\n        if (nextInfo === undefined) {\n          nextInfo = {\n            minAvailableModules: undefined,\n            availableModulesToBeMerged: []\n          };\n          chunkGroupInfoMap.set(nextChunkGroup, nextInfo);\n        }\n        nextInfo.availableModulesToBeMerged.push(newAvailableModules);\n\n        // As queue deduplicates enqueued items this makes sure that a ChunkGroup\n        // is not enqueued twice\n        queue2.enqueue(nextChunkGroup);\n      }\n    }\n\n    // Remove all unconnected chunk groups\n    for (const chunkGroup of allCreatedChunkGroups) {\n      if (chunkGroup.getNumberOfParents() === 0) {\n        for (const chunk of chunkGroup.chunks) {\n          const idx = this.chunks.indexOf(chunk);\n          if (idx >= 0) this.chunks.splice(idx, 1);\n          chunk.remove(\"unconnected\");\n        }\n        chunkGroup.remove(\"unconnected\");\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {Module} module module relationship for removal\n   * @param {DependenciesBlockLike} block //TODO: good description\n   * @returns {void}\n   */\n  removeReasonsOfDependencyBlock(module, block) {\n    const iteratorDependency = d => {\n      if (!d.module) {\n        return;\n      }\n      if (d.module.removeReason(module, d)) {\n        for (const chunk of d.module.chunksIterable) {\n          this.patchChunksAfterReasonRemoval(d.module, chunk);\n        }\n      }\n    };\n    if (block.blocks) {\n      iterationOfArrayCallback(block.blocks, block => this.removeReasonsOfDependencyBlock(module, block));\n    }\n    if (block.dependencies) {\n      iterationOfArrayCallback(block.dependencies, iteratorDependency);\n    }\n    if (block.variables) {\n      iterationBlockVariable(block.variables, iteratorDependency);\n    }\n  }\n\n  /**\n   * @param {Module} module module to patch tie\n   * @param {Chunk} chunk chunk to patch tie\n   * @returns {void}\n   */\n  patchChunksAfterReasonRemoval(module, chunk) {\n    if (!module.hasReasons()) {\n      this.removeReasonsOfDependencyBlock(module, module);\n    }\n    if (!module.hasReasonForChunk(chunk)) {\n      if (module.removeChunk(chunk)) {\n        this.removeChunkFromDependencies(module, chunk);\n      }\n    }\n  }\n\n  /**\n   *\n   * @param {DependenciesBlock} block block tie for Chunk\n   * @param {Chunk} chunk chunk to remove from dep\n   * @returns {void}\n   */\n  removeChunkFromDependencies(block, chunk) {\n    const iteratorDependency = d => {\n      if (!d.module) {\n        return;\n      }\n      this.patchChunksAfterReasonRemoval(d.module, chunk);\n    };\n    const blocks = block.blocks;\n    for (let indexBlock = 0; indexBlock < blocks.length; indexBlock++) {\n      const asyncBlock = blocks[indexBlock];\n      // Grab all chunks from the first Block's AsyncDepBlock\n      const chunks = asyncBlock.chunkGroup.chunks;\n      // For each chunk in chunkGroup\n      for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n        const iteratedChunk = chunks[indexChunk];\n        asyncBlock.chunkGroup.removeChunk(iteratedChunk);\n        asyncBlock.chunkGroup.removeParent(iteratedChunk);\n        // Recurse\n        this.removeChunkFromDependencies(block, iteratedChunk);\n      }\n    }\n    if (block.dependencies) {\n      iterationOfArrayCallback(block.dependencies, iteratorDependency);\n    }\n    if (block.variables) {\n      iterationBlockVariable(block.variables, iteratorDependency);\n    }\n  }\n  applyModuleIds() {\n    const unusedIds = [];\n    let nextFreeModuleId = 0;\n    const usedIds = new Set();\n    if (this.usedModuleIds) {\n      for (const id of this.usedModuleIds) {\n        usedIds.add(id);\n      }\n    }\n    const modules1 = this.modules;\n    for (let indexModule1 = 0; indexModule1 < modules1.length; indexModule1++) {\n      const module1 = modules1[indexModule1];\n      if (module1.id !== null) {\n        usedIds.add(module1.id);\n      }\n    }\n    if (usedIds.size > 0) {\n      let usedIdMax = -1;\n      for (const usedIdKey of usedIds) {\n        if (typeof usedIdKey !== \"number\") {\n          continue;\n        }\n        usedIdMax = Math.max(usedIdMax, usedIdKey);\n      }\n      let lengthFreeModules = nextFreeModuleId = usedIdMax + 1;\n      while (lengthFreeModules--) {\n        if (!usedIds.has(lengthFreeModules)) {\n          unusedIds.push(lengthFreeModules);\n        }\n      }\n    }\n    const modules2 = this.modules;\n    for (let indexModule2 = 0; indexModule2 < modules2.length; indexModule2++) {\n      const module2 = modules2[indexModule2];\n      if (module2.id === null) {\n        if (unusedIds.length > 0) {\n          module2.id = unusedIds.pop();\n        } else {\n          module2.id = nextFreeModuleId++;\n        }\n      }\n    }\n  }\n  applyChunkIds() {\n    /** @type {Set<number>} */\n    const usedIds = new Set();\n\n    // Get used ids from usedChunkIds property (i. e. from records)\n    if (this.usedChunkIds) {\n      for (const id of this.usedChunkIds) {\n        if (typeof id !== \"number\") {\n          continue;\n        }\n        usedIds.add(id);\n      }\n    }\n\n    // Get used ids from existing chunks\n    const chunks = this.chunks;\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      const chunk = chunks[indexChunk];\n      const usedIdValue = chunk.id;\n      if (typeof usedIdValue !== \"number\") {\n        continue;\n      }\n      usedIds.add(usedIdValue);\n    }\n\n    // Calculate maximum assigned chunk id\n    let nextFreeChunkId = -1;\n    for (const id of usedIds) {\n      nextFreeChunkId = Math.max(nextFreeChunkId, id);\n    }\n    nextFreeChunkId++;\n\n    // Determine free chunk ids from 0 to maximum\n    /** @type {number[]} */\n    const unusedIds = [];\n    if (nextFreeChunkId > 0) {\n      let index = nextFreeChunkId;\n      while (index--) {\n        if (!usedIds.has(index)) {\n          unusedIds.push(index);\n        }\n      }\n    }\n\n    // Assign ids to chunk which has no id\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      const chunk = chunks[indexChunk];\n      if (chunk.id === null) {\n        if (unusedIds.length > 0) {\n          chunk.id = unusedIds.pop();\n        } else {\n          chunk.id = nextFreeChunkId++;\n        }\n      }\n      if (!chunk.ids) {\n        chunk.ids = [chunk.id];\n      }\n    }\n  }\n  sortItemsWithModuleIds() {\n    this.modules.sort(byIdOrIdentifier);\n    const modules = this.modules;\n    for (let indexModule = 0; indexModule < modules.length; indexModule++) {\n      modules[indexModule].sortItems(false);\n    }\n    const chunks = this.chunks;\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      chunks[indexChunk].sortItems();\n    }\n    chunks.sort((a, b) => a.compareTo(b));\n  }\n  sortItemsWithChunkIds() {\n    for (const chunkGroup of this.chunkGroups) {\n      chunkGroup.sortItems();\n    }\n    this.chunks.sort(byId);\n    for (let indexModule = 0; indexModule < this.modules.length; indexModule++) {\n      this.modules[indexModule].sortItems(true);\n    }\n    const chunks = this.chunks;\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      chunks[indexChunk].sortItems();\n    }\n\n    /**\n     * Used to sort errors and warnings in compilation. this.warnings, and\n     * this.errors contribute to the compilation hash and therefore should be\n     * updated whenever other references (having a chunk id) are sorted. This preserves the hash\n     * integrity\n     *\n     * @param {WebpackError} a first WebpackError instance (including subclasses)\n     * @param {WebpackError} b second WebpackError instance (including subclasses)\n     * @returns {-1|0|1} sort order index\n     */\n    const byMessage = (a, b) => {\n      const ma = `${a.message}`;\n      const mb = `${b.message}`;\n      if (ma < mb) return -1;\n      if (mb < ma) return 1;\n      return 0;\n    };\n    this.errors.sort(byMessage);\n    this.warnings.sort(byMessage);\n    this.children.sort(byNameOrHash);\n  }\n  summarizeDependencies() {\n    this.fileDependencies = new SortableSet(this.compilationDependencies);\n    this.contextDependencies = new SortableSet();\n    this.missingDependencies = new SortableSet();\n    for (let indexChildren = 0; indexChildren < this.children.length; indexChildren++) {\n      const child = this.children[indexChildren];\n      addAllToSet(this.fileDependencies, child.fileDependencies);\n      addAllToSet(this.contextDependencies, child.contextDependencies);\n      addAllToSet(this.missingDependencies, child.missingDependencies);\n    }\n    for (let indexModule = 0; indexModule < this.modules.length; indexModule++) {\n      const module = this.modules[indexModule];\n      if (module.buildInfo.fileDependencies) {\n        addAllToSet(this.fileDependencies, module.buildInfo.fileDependencies);\n      }\n      if (module.buildInfo.contextDependencies) {\n        addAllToSet(this.contextDependencies, module.buildInfo.contextDependencies);\n      }\n    }\n    for (const error of this.errors) {\n      if (typeof error.missing === \"object\" && error.missing && error.missing[Symbol.iterator]) {\n        addAllToSet(this.missingDependencies, error.missing);\n      }\n    }\n    this.fileDependencies.sort();\n    this.contextDependencies.sort();\n    this.missingDependencies.sort();\n  }\n  createHash() {\n    const outputOptions = this.outputOptions;\n    const hashFunction = outputOptions.hashFunction;\n    const hashDigest = outputOptions.hashDigest;\n    const hashDigestLength = outputOptions.hashDigestLength;\n    const hash = createHash(hashFunction);\n    if (outputOptions.hashSalt) {\n      hash.update(outputOptions.hashSalt);\n    }\n    this.mainTemplate.updateHash(hash);\n    this.chunkTemplate.updateHash(hash);\n    for (const key of Object.keys(this.moduleTemplates).sort()) {\n      this.moduleTemplates[key].updateHash(hash);\n    }\n    for (const child of this.children) {\n      hash.update(child.hash);\n    }\n    for (const warning of this.warnings) {\n      hash.update(`${warning.message}`);\n    }\n    for (const error of this.errors) {\n      hash.update(`${error.message}`);\n    }\n    const modules = this.modules;\n    for (let i = 0; i < modules.length; i++) {\n      const module = modules[i];\n      const moduleHash = createHash(hashFunction);\n      module.updateHash(moduleHash);\n      module.hash = moduleHash.digest(hashDigest);\n      module.renderedHash = module.hash.substr(0, hashDigestLength);\n    }\n    // clone needed as sort below is inplace mutation\n    const chunks = this.chunks.slice();\n    /**\n     * sort here will bring all \"falsy\" values to the beginning\n     * this is needed as the \"hasRuntime()\" chunks are dependent on the\n     * hashes of the non-runtime chunks.\n     */\n    chunks.sort((a, b) => {\n      const aEntry = a.hasRuntime();\n      const bEntry = b.hasRuntime();\n      if (aEntry && !bEntry) return 1;\n      if (!aEntry && bEntry) return -1;\n      return byId(a, b);\n    });\n    for (let i = 0; i < chunks.length; i++) {\n      const chunk = chunks[i];\n      const chunkHash = createHash(hashFunction);\n      try {\n        if (outputOptions.hashSalt) {\n          chunkHash.update(outputOptions.hashSalt);\n        }\n        chunk.updateHash(chunkHash);\n        const template = chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate;\n        template.updateHashForChunk(chunkHash, chunk, this.moduleTemplates.javascript, this.dependencyTemplates);\n        this.hooks.chunkHash.call(chunk, chunkHash);\n        chunk.hash = chunkHash.digest(hashDigest);\n        hash.update(chunk.hash);\n        chunk.renderedHash = chunk.hash.substr(0, hashDigestLength);\n        this.hooks.contentHash.call(chunk);\n      } catch (err) {\n        this.errors.push(new ChunkRenderError(chunk, \"\", err));\n      }\n    }\n    this.fullHash = hash.digest(hashDigest);\n    this.hash = this.fullHash.substr(0, hashDigestLength);\n  }\n\n  /**\n   * @param {string} update extra information\n   * @returns {void}\n   */\n  modifyHash(update) {\n    const outputOptions = this.outputOptions;\n    const hashFunction = outputOptions.hashFunction;\n    const hashDigest = outputOptions.hashDigest;\n    const hashDigestLength = outputOptions.hashDigestLength;\n    const hash = createHash(hashFunction);\n    hash.update(this.fullHash);\n    hash.update(update);\n    this.fullHash = hash.digest(hashDigest);\n    this.hash = this.fullHash.substr(0, hashDigestLength);\n  }\n  createModuleAssets() {\n    for (let i = 0; i < this.modules.length; i++) {\n      const module = this.modules[i];\n      if (module.buildInfo.assets) {\n        for (const assetName of Object.keys(module.buildInfo.assets)) {\n          const fileName = this.getPath(assetName);\n          this.assets[fileName] = module.buildInfo.assets[assetName];\n          this.hooks.moduleAsset.call(module, fileName);\n        }\n      }\n    }\n  }\n  createChunkAssets() {\n    const outputOptions = this.outputOptions;\n    const cachedSourceMap = new Map();\n    /** @type {Map<string, {hash: string, source: Source, chunk: Chunk}>} */\n    const alreadyWrittenFiles = new Map();\n    for (let i = 0; i < this.chunks.length; i++) {\n      const chunk = this.chunks[i];\n      chunk.files = [];\n      let source;\n      let file;\n      let filenameTemplate;\n      try {\n        const template = chunk.hasRuntime() ? this.mainTemplate : this.chunkTemplate;\n        const manifest = template.getRenderManifest({\n          chunk,\n          hash: this.hash,\n          fullHash: this.fullHash,\n          outputOptions,\n          moduleTemplates: this.moduleTemplates,\n          dependencyTemplates: this.dependencyTemplates\n        }); // [{ render(), filenameTemplate, pathOptions, identifier, hash }]\n        for (const fileManifest of manifest) {\n          const cacheName = fileManifest.identifier;\n          const usedHash = fileManifest.hash;\n          filenameTemplate = fileManifest.filenameTemplate;\n          file = this.getPath(filenameTemplate, fileManifest.pathOptions);\n\n          // check if the same filename was already written by another chunk\n          const alreadyWritten = alreadyWrittenFiles.get(file);\n          if (alreadyWritten !== undefined) {\n            if (alreadyWritten.hash === usedHash) {\n              if (this.cache) {\n                this.cache[cacheName] = {\n                  hash: usedHash,\n                  source: alreadyWritten.source\n                };\n              }\n              chunk.files.push(file);\n              this.hooks.chunkAsset.call(chunk, file);\n              continue;\n            } else {\n              throw new Error(`Conflict: Multiple chunks emit assets to the same filename ${file}` + ` (chunks ${alreadyWritten.chunk.id} and ${chunk.id})`);\n            }\n          }\n          if (this.cache && this.cache[cacheName] && this.cache[cacheName].hash === usedHash) {\n            source = this.cache[cacheName].source;\n          } else {\n            source = fileManifest.render();\n            // Ensure that source is a cached source to avoid additional cost because of repeated access\n            if (!(source instanceof CachedSource)) {\n              const cacheEntry = cachedSourceMap.get(source);\n              if (cacheEntry) {\n                source = cacheEntry;\n              } else {\n                const cachedSource = new CachedSource(source);\n                cachedSourceMap.set(source, cachedSource);\n                source = cachedSource;\n              }\n            }\n            if (this.cache) {\n              this.cache[cacheName] = {\n                hash: usedHash,\n                source\n              };\n            }\n          }\n          if (this.assets[file] && this.assets[file] !== source) {\n            throw new Error(`Conflict: Multiple assets emit to the same filename ${file}`);\n          }\n          this.assets[file] = source;\n          chunk.files.push(file);\n          this.hooks.chunkAsset.call(chunk, file);\n          alreadyWrittenFiles.set(file, {\n            hash: usedHash,\n            source,\n            chunk\n          });\n        }\n      } catch (err) {\n        this.errors.push(new ChunkRenderError(chunk, file || filenameTemplate, err));\n      }\n    }\n  }\n\n  /**\n   * @param {string} filename used to get asset path with hash\n   * @param {TODO=} data // TODO: figure out this param type\n   * @returns {string} interpolated path\n   */\n  getPath(filename, data) {\n    data = data || {};\n    data.hash = data.hash || this.hash;\n    return this.mainTemplate.getAssetPath(filename, data);\n  }\n\n  /**\n   * This function allows you to run another instance of webpack inside of webpack however as\n   * a child with different settings and configurations (if desired) applied. It copies all hooks, plugins\n   * from parent (or top level compiler) and creates a child Compilation\n   *\n   * @param {string} name name of the child compiler\n   * @param {TODO} outputOptions // Need to convert config schema to types for this\n   * @param {Plugin[]} plugins webpack plugins that will be applied\n   * @returns {Compiler} creates a child Compiler instance\n   */\n  createChildCompiler(name, outputOptions, plugins) {\n    const idx = this.childrenCounters[name] || 0;\n    this.childrenCounters[name] = idx + 1;\n    return this.compiler.createChildCompiler(this, name, idx, outputOptions, plugins);\n  }\n  checkConstraints() {\n    /** @type {Set<number|string>} */\n    const usedIds = new Set();\n    const modules = this.modules;\n    for (let indexModule = 0; indexModule < modules.length; indexModule++) {\n      const moduleId = modules[indexModule].id;\n      if (moduleId === null) continue;\n      if (usedIds.has(moduleId)) {\n        throw new Error(`checkConstraints: duplicate module id ${moduleId}`);\n      }\n      usedIds.add(moduleId);\n    }\n    const chunks = this.chunks;\n    for (let indexChunk = 0; indexChunk < chunks.length; indexChunk++) {\n      const chunk = chunks[indexChunk];\n      if (chunks.indexOf(chunk) !== indexChunk) {\n        throw new Error(`checkConstraints: duplicate chunk in compilation ${chunk.debugId}`);\n      }\n    }\n    for (const chunkGroup of this.chunkGroups) {\n      chunkGroup.checkConstraints();\n    }\n  }\n}\n\n// TODO remove in webpack 5\nCompilation.prototype.applyPlugins = util.deprecate(\n/**\n * @deprecated\n * @param {string} name Name\n * @param {any[]} args Other arguments\n * @returns {void}\n * @this {Compilation}\n */\nfunction (name, ...args) {\n  this.hooks[name.replace(/[- ]([a-z])/g, match => match[1].toUpperCase())].call(...args);\n}, \"Compilation.applyPlugins is deprecated. Use new API on `.hooks` instead\");\n\n// TODO remove in webpack 5\nObject.defineProperty(Compilation.prototype, \"moduleTemplate\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @this {Compilation}\n   * @returns {TODO} module template\n   */\n  function () {\n    return this.moduleTemplates.javascript;\n  }, \"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @param {ModuleTemplate} value Template value\n   * @this {Compilation}\n   * @returns {void}\n   */\n  function (value) {\n    this.moduleTemplates.javascript = value;\n  }, \"Compilation.moduleTemplate: Use Compilation.moduleTemplates.javascript instead.\")\n});\nmodule.exports = Compilation;","map":null,"metadata":{},"sourceType":"script"}