{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst Template = require(\"../Template\");\nconst WebAssemblyUtils = require(\"./WebAssemblyUtils\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../MainTemplate\")} MainTemplate */\n\n// Get all wasm modules\nconst getAllWasmModules = chunk => {\n  const wasmModules = chunk.getAllAsyncChunks();\n  const array = [];\n  for (const chunk of wasmModules) {\n    for (const m of chunk.modulesIterable) {\n      if (m.type.startsWith(\"webassembly\")) {\n        array.push(m);\n      }\n    }\n  }\n  return array;\n};\n\n/**\n * generates the import object function for a module\n * @param {Module} module the module\n * @param {boolean} mangle mangle imports\n * @returns {string} source code\n */\nconst generateImportObject = (module, mangle) => {\n  const waitForInstances = new Map();\n  const properties = [];\n  const usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(module, mangle);\n  for (const usedDep of usedWasmDependencies) {\n    const dep = usedDep.dependency;\n    const importedModule = dep.module;\n    const exportName = dep.name;\n    const usedName = importedModule && importedModule.isUsed(exportName);\n    const description = dep.description;\n    const direct = dep.onlyDirectImport;\n    const module = usedDep.module;\n    const name = usedDep.name;\n    if (direct) {\n      const instanceVar = `m${waitForInstances.size}`;\n      waitForInstances.set(instanceVar, importedModule.id);\n      properties.push({\n        module,\n        name,\n        value: `${instanceVar}[${JSON.stringify(usedName)}]`\n      });\n    } else {\n      const params = description.signature.params.map((param, k) => \"p\" + k + param.valtype);\n      const mod = `installedModules[${JSON.stringify(importedModule.id)}]`;\n      const func = `${mod}.exports[${JSON.stringify(usedName)}]`;\n      properties.push({\n        module,\n        name,\n        value: Template.asString([(importedModule.type.startsWith(\"webassembly\") ? `${mod} ? ${func} : ` : \"\") + `function(${params}) {`, Template.indent([`return ${func}(${params});`]), \"}\"])\n      });\n    }\n  }\n  let importObject;\n  if (mangle) {\n    importObject = [\"return {\", Template.indent([properties.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")]), \"};\"];\n  } else {\n    const propertiesByModule = new Map();\n    for (const p of properties) {\n      let list = propertiesByModule.get(p.module);\n      if (list === undefined) {\n        propertiesByModule.set(p.module, list = []);\n      }\n      list.push(p);\n    }\n    importObject = [\"return {\", Template.indent([Array.from(propertiesByModule, ([module, list]) => {\n      return Template.asString([`${JSON.stringify(module)}: {`, Template.indent([list.map(p => `${JSON.stringify(p.name)}: ${p.value}`).join(\",\\n\")]), \"}\"]);\n    }).join(\",\\n\")]), \"};\"];\n  }\n  if (waitForInstances.size === 1) {\n    const moduleId = Array.from(waitForInstances.values())[0];\n    const promise = `installedWasmModules[${JSON.stringify(moduleId)}]`;\n    const variable = Array.from(waitForInstances.keys())[0];\n    return Template.asString([`${JSON.stringify(module.id)}: function() {`, Template.indent([`return promiseResolve().then(function() { return ${promise}; }).then(function(${variable}) {`, Template.indent(importObject), \"});\"]), \"},\"]);\n  } else if (waitForInstances.size > 0) {\n    const promises = Array.from(waitForInstances.values(), id => `installedWasmModules[${JSON.stringify(id)}]`).join(\", \");\n    const variables = Array.from(waitForInstances.keys(), (name, i) => `${name} = array[${i}]`).join(\", \");\n    return Template.asString([`${JSON.stringify(module.id)}: function() {`, Template.indent([`return promiseResolve().then(function() { return Promise.all([${promises}]); }).then(function(array) {`, Template.indent([`var ${variables};`, ...importObject]), \"});\"]), \"},\"]);\n  } else {\n    return Template.asString([`${JSON.stringify(module.id)}: function() {`, Template.indent(importObject), \"},\"]);\n  }\n};\nclass WasmMainTemplatePlugin {\n  constructor({\n    generateLoadBinaryCode,\n    supportsStreaming,\n    mangleImports\n  }) {\n    this.generateLoadBinaryCode = generateLoadBinaryCode;\n    this.supportsStreaming = supportsStreaming;\n    this.mangleImports = mangleImports;\n  }\n\n  /**\n   * @param {MainTemplate} mainTemplate main template\n   * @returns {void}\n   */\n  apply(mainTemplate) {\n    mainTemplate.hooks.localVars.tap(\"WasmMainTemplatePlugin\", (source, chunk) => {\n      const wasmModules = getAllWasmModules(chunk);\n      if (wasmModules.length === 0) return source;\n      const importObjects = wasmModules.map(module => {\n        return generateImportObject(module, this.mangleImports);\n      });\n      return Template.asString([source, \"\", \"// object to store loaded and loading wasm modules\", \"var installedWasmModules = {};\", \"\",\n      // This function is used to delay reading the installed wasm module promises\n      // by a microtask. Sorting them doesn't help because there are egdecases where\n      // sorting is not possible (modules splitted into different chunks).\n      // So we not even trying and solve this by a microtask delay.\n      \"function promiseResolve() { return Promise.resolve(); }\", \"\", \"var wasmImportObjects = {\", Template.indent(importObjects), \"};\"]);\n    });\n    mainTemplate.hooks.requireEnsure.tap(\"WasmMainTemplatePlugin\", (source, chunk, hash) => {\n      const webassemblyModuleFilename = mainTemplate.outputOptions.webassemblyModuleFilename;\n      const chunkModuleMaps = chunk.getChunkModuleMaps(m => m.type.startsWith(\"webassembly\"));\n      if (Object.keys(chunkModuleMaps.id).length === 0) return source;\n      const wasmModuleSrcPath = mainTemplate.getAssetPath(JSON.stringify(webassemblyModuleFilename), {\n        hash: `\" + ${mainTemplate.renderCurrentHashCode(hash)} + \"`,\n        hashWithLength: length => `\" + ${mainTemplate.renderCurrentHashCode(hash, length)} + \"`,\n        module: {\n          id: '\" + wasmModuleId + \"',\n          hash: `\" + ${JSON.stringify(chunkModuleMaps.hash)}[wasmModuleId] + \"`,\n          hashWithLength(length) {\n            const shortChunkHashMap = Object.create(null);\n            for (const wasmModuleId of Object.keys(chunkModuleMaps.hash)) {\n              if (typeof chunkModuleMaps.hash[wasmModuleId] === \"string\") {\n                shortChunkHashMap[wasmModuleId] = chunkModuleMaps.hash[wasmModuleId].substr(0, length);\n              }\n            }\n            return `\" + ${JSON.stringify(shortChunkHashMap)}[wasmModuleId] + \"`;\n          }\n        }\n      });\n      const createImportObject = content => this.mangleImports ? `{ ${JSON.stringify(WebAssemblyUtils.MANGLED_MODULE)}: ${content} }` : content;\n      return Template.asString([source, \"\", \"// Fetch + compile chunk loading for webassembly\", \"\", `var wasmModules = ${JSON.stringify(chunkModuleMaps.id)}[chunkId] || [];`, \"\", \"wasmModules.forEach(function(wasmModuleId) {\", Template.indent([\"var installedWasmModuleData = installedWasmModules[wasmModuleId];\", \"\", '// a Promise means \"currently loading\" or \"already loaded\".', \"if(installedWasmModuleData)\", Template.indent([\"promises.push(installedWasmModuleData);\"]), \"else {\", Template.indent([`var importObject = wasmImportObjects[wasmModuleId]();`, `var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)};`, \"var promise;\", this.supportsStreaming ? Template.asString([\"if(importObject instanceof Promise && typeof WebAssembly.compileStreaming === 'function') {\", Template.indent([\"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {\", Template.indent([`return WebAssembly.instantiate(items[0], ${createImportObject(\"items[1]\")});`]), \"});\"]), \"} else if(typeof WebAssembly.instantiateStreaming === 'function') {\", Template.indent([`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(\"importObject\")});`])]) : Template.asString([\"if(importObject instanceof Promise) {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = Promise.all([\", Template.indent([\"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); }),\", \"importObject\"]), \"]).then(function(items) {\", Template.indent([`return WebAssembly.instantiate(items[0], ${createImportObject(\"items[1]\")});`]), \"});\"])]), \"} else {\", Template.indent([\"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); });\", \"promise = bytesPromise.then(function(bytes) {\", Template.indent([`return WebAssembly.instantiate(bytes, ${createImportObject(\"importObject\")});`]), \"});\"]), \"}\", \"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {\", Template.indent([`return ${mainTemplate.requireFn}.w[wasmModuleId] = (res.instance || res).exports;`]), \"}));\"]), \"}\"]), \"});\"]);\n    });\n    mainTemplate.hooks.requireExtensions.tap(\"WasmMainTemplatePlugin\", (source, chunk) => {\n      if (!chunk.hasModuleInGraph(m => m.type.startsWith(\"webassembly\"))) {\n        return source;\n      }\n      return Template.asString([source, \"\", \"// object with all WebAssembly.instance exports\", `${mainTemplate.requireFn}.w = {};`]);\n    });\n    mainTemplate.hooks.hash.tap(\"WasmMainTemplatePlugin\", hash => {\n      hash.update(\"WasmMainTemplatePlugin\");\n      hash.update(\"2\");\n    });\n  }\n}\nmodule.exports = WasmMainTemplatePlugin;","map":null,"metadata":{},"sourceType":"script"}