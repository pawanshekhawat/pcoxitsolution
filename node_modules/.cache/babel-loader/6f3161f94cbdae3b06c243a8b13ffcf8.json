{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst path = require(\"path\");\nconst ParserHelpers = require(\"./ParserHelpers\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst NullFactory = require(\"./NullFactory\");\nclass NodeStuffPlugin {\n  constructor(options) {\n    this.options = options;\n  }\n  apply(compiler) {\n    const options = this.options;\n    compiler.hooks.compilation.tap(\"NodeStuffPlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      compilation.dependencyFactories.set(ConstDependency, new NullFactory());\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n      const handler = (parser, parserOptions) => {\n        if (parserOptions.node === false) return;\n        let localOptions = options;\n        if (parserOptions.node) {\n          localOptions = Object.assign({}, localOptions, parserOptions.node);\n        }\n        const setConstant = (expressionName, value) => {\n          parser.hooks.expression.for(expressionName).tap(\"NodeStuffPlugin\", () => {\n            parser.state.current.addVariable(expressionName, JSON.stringify(value));\n            return true;\n          });\n        };\n        const setModuleConstant = (expressionName, fn) => {\n          parser.hooks.expression.for(expressionName).tap(\"NodeStuffPlugin\", () => {\n            parser.state.current.addVariable(expressionName, JSON.stringify(fn(parser.state.module)));\n            return true;\n          });\n        };\n        const context = compiler.context;\n        if (localOptions.__filename === \"mock\") {\n          setConstant(\"__filename\", \"/index.js\");\n        } else if (localOptions.__filename) {\n          setModuleConstant(\"__filename\", module => path.relative(context, module.resource));\n        }\n        parser.hooks.evaluateIdentifier.for(\"__filename\").tap(\"NodeStuffPlugin\", expr => {\n          if (!parser.state.module) return;\n          const resource = parser.state.module.resource;\n          const i = resource.indexOf(\"?\");\n          return ParserHelpers.evaluateToString(i < 0 ? resource : resource.substr(0, i))(expr);\n        });\n        if (localOptions.__dirname === \"mock\") {\n          setConstant(\"__dirname\", \"/\");\n        } else if (localOptions.__dirname) {\n          setModuleConstant(\"__dirname\", module => path.relative(context, module.context));\n        }\n        parser.hooks.evaluateIdentifier.for(\"__dirname\").tap(\"NodeStuffPlugin\", expr => {\n          if (!parser.state.module) return;\n          return ParserHelpers.evaluateToString(parser.state.module.context)(expr);\n        });\n        parser.hooks.expression.for(\"require.main\").tap(\"NodeStuffPlugin\", ParserHelpers.toConstantDependencyWithWebpackRequire(parser, \"__webpack_require__.c[__webpack_require__.s]\"));\n        parser.hooks.expression.for(\"require.extensions\").tap(\"NodeStuffPlugin\", ParserHelpers.expressionIsUnsupported(parser, \"require.extensions is not supported by webpack. Use a loader instead.\"));\n        parser.hooks.expression.for(\"require.main.require\").tap(\"NodeStuffPlugin\", ParserHelpers.expressionIsUnsupported(parser, \"require.main.require is not supported by webpack.\"));\n        parser.hooks.expression.for(\"module.parent.require\").tap(\"NodeStuffPlugin\", ParserHelpers.expressionIsUnsupported(parser, \"module.parent.require is not supported by webpack.\"));\n        parser.hooks.expression.for(\"module.loaded\").tap(\"NodeStuffPlugin\", expr => {\n          parser.state.module.buildMeta.moduleConcatenationBailout = \"module.loaded\";\n          return ParserHelpers.toConstantDependency(parser, \"module.l\")(expr);\n        });\n        parser.hooks.expression.for(\"module.id\").tap(\"NodeStuffPlugin\", expr => {\n          parser.state.module.buildMeta.moduleConcatenationBailout = \"module.id\";\n          return ParserHelpers.toConstantDependency(parser, \"module.i\")(expr);\n        });\n        parser.hooks.expression.for(\"module.exports\").tap(\"NodeStuffPlugin\", () => {\n          const module = parser.state.module;\n          const isHarmony = module.buildMeta && module.buildMeta.exportsType;\n          if (!isHarmony) return true;\n        });\n        parser.hooks.evaluateIdentifier.for(\"module.hot\").tap(\"NodeStuffPlugin\", ParserHelpers.evaluateToIdentifier(\"module.hot\", false));\n        parser.hooks.expression.for(\"module\").tap(\"NodeStuffPlugin\", () => {\n          const module = parser.state.module;\n          const isHarmony = module.buildMeta && module.buildMeta.exportsType;\n          let moduleJsPath = path.join(__dirname, \"..\", \"buildin\", isHarmony ? \"harmony-module.js\" : \"module.js\");\n          if (module.context) {\n            moduleJsPath = path.relative(parser.state.module.context, moduleJsPath);\n            if (!/^[A-Z]:/i.test(moduleJsPath)) {\n              moduleJsPath = `./${moduleJsPath.replace(/\\\\/g, \"/\")}`;\n            }\n          }\n          return ParserHelpers.addParsedVariableToModule(parser, \"module\", `require(${JSON.stringify(moduleJsPath)})(module)`);\n        });\n      };\n      normalModuleFactory.hooks.parser.for(\"javascript/auto\").tap(\"NodeStuffPlugin\", handler);\n      normalModuleFactory.hooks.parser.for(\"javascript/dynamic\").tap(\"NodeStuffPlugin\", handler);\n    });\n  }\n}\nmodule.exports = NodeStuffPlugin;","map":null,"metadata":{},"sourceType":"script"}