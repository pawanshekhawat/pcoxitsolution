{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst parseJson = require(\"json-parse-better-errors\");\nconst asyncLib = require(\"neo-async\");\nconst path = require(\"path\");\nconst {\n  Source\n} = require(\"webpack-sources\");\nconst util = require(\"util\");\nconst {\n  Tapable,\n  SyncHook,\n  SyncBailHook,\n  AsyncParallelHook,\n  AsyncSeriesHook\n} = require(\"tapable\");\nconst Compilation = require(\"./Compilation\");\nconst Stats = require(\"./Stats\");\nconst Watching = require(\"./Watching\");\nconst NormalModuleFactory = require(\"./NormalModuleFactory\");\nconst ContextModuleFactory = require(\"./ContextModuleFactory\");\nconst ResolverFactory = require(\"./ResolverFactory\");\nconst RequestShortener = require(\"./RequestShortener\");\nconst {\n  makePathsRelative\n} = require(\"./util/identifier\");\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\n\n/** @typedef {import(\"../declarations/WebpackOptions\").Entry} Entry */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptions} WebpackOptions */\n\n/**\n * @typedef {Object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n * @property {Set<string>} compilationDependencies\n */\n\nclass Compiler extends Tapable {\n  constructor(context) {\n    super();\n    this.hooks = {\n      /** @type {SyncBailHook<Compilation>} */\n      shouldEmit: new SyncBailHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<Stats>} */\n      done: new AsyncSeriesHook([\"stats\"]),\n      /** @type {AsyncSeriesHook<>} */\n      additionalPass: new AsyncSeriesHook([]),\n      /** @type {AsyncSeriesHook<Compiler>} */\n      beforeRun: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {AsyncSeriesHook<Compiler>} */\n      run: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {AsyncSeriesHook<Compilation>} */\n      emit: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<Compilation>} */\n      afterEmit: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {SyncHook<Compilation, CompilationParams>} */\n      thisCompilation: new SyncHook([\"compilation\", \"params\"]),\n      /** @type {SyncHook<Compilation, CompilationParams>} */\n      compilation: new SyncHook([\"compilation\", \"params\"]),\n      /** @type {SyncHook<NormalModuleFactory>} */\n      normalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n      /** @type {SyncHook<ContextModuleFactory>}  */\n      contextModuleFactory: new SyncHook([\"contextModulefactory\"]),\n      /** @type {AsyncSeriesHook<CompilationParams>} */\n      beforeCompile: new AsyncSeriesHook([\"params\"]),\n      /** @type {SyncHook<CompilationParams>} */\n      compile: new SyncHook([\"params\"]),\n      /** @type {AsyncParallelHook<Compilation>} */\n      make: new AsyncParallelHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<Compilation>} */\n      afterCompile: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<Compiler>} */\n      watchRun: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {SyncHook<Error>} */\n      failed: new SyncHook([\"error\"]),\n      /** @type {SyncHook<string, string>} */\n      invalid: new SyncHook([\"filename\", \"changeTime\"]),\n      /** @type {SyncHook} */\n      watchClose: new SyncHook([]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n      /** @type {SyncHook} */\n      environment: new SyncHook([]),\n      /** @type {SyncHook} */\n      afterEnvironment: new SyncHook([]),\n      /** @type {SyncHook<Compiler>} */\n      afterPlugins: new SyncHook([\"compiler\"]),\n      /** @type {SyncHook<Compiler>} */\n      afterResolvers: new SyncHook([\"compiler\"]),\n      /** @type {SyncBailHook<string, Entry>} */\n      entryOption: new SyncBailHook([\"context\", \"entry\"])\n    };\n    this._pluginCompat.tap(\"Compiler\", options => {\n      switch (options.name) {\n        case \"additional-pass\":\n        case \"before-run\":\n        case \"run\":\n        case \"emit\":\n        case \"after-emit\":\n        case \"before-compile\":\n        case \"make\":\n        case \"after-compile\":\n        case \"watch-run\":\n          options.async = true;\n          break;\n      }\n    });\n\n    /** @type {string=} */\n    this.name = undefined;\n    /** @type {Compilation=} */\n    this.parentCompilation = undefined;\n    /** @type {string} */\n    this.outputPath = \"\";\n    this.outputFileSystem = null;\n    this.inputFileSystem = null;\n\n    /** @type {string|null} */\n    this.recordsInputPath = null;\n    /** @type {string|null} */\n    this.recordsOutputPath = null;\n    this.records = {};\n    this.removedFiles = new Set();\n    /** @type {Map<string, number>} */\n    this.fileTimestamps = new Map();\n    /** @type {Map<string, number>} */\n    this.contextTimestamps = new Map();\n    /** @type {ResolverFactory} */\n    this.resolverFactory = new ResolverFactory();\n\n    // TODO remove in webpack 5\n    this.resolvers = {\n      normal: {\n        plugins: util.deprecate((hook, fn) => {\n          this.resolverFactory.plugin(\"resolver normal\", resolver => {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate((...args) => {\n          this.resolverFactory.plugin(\"resolver normal\", resolver => {\n            resolver.apply(...args);\n          });\n        }, \"webpack: Using compiler.resolvers.normal is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver normal\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      },\n      loader: {\n        plugins: util.deprecate((hook, fn) => {\n          this.resolverFactory.plugin(\"resolver loader\", resolver => {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate((...args) => {\n          this.resolverFactory.plugin(\"resolver loader\", resolver => {\n            resolver.apply(...args);\n          });\n        }, \"webpack: Using compiler.resolvers.loader is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver loader\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      },\n      context: {\n        plugins: util.deprecate((hook, fn) => {\n          this.resolverFactory.plugin(\"resolver context\", resolver => {\n            resolver.plugin(hook, fn);\n          });\n        }, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.plugin(/* … */);\\n}); instead.'),\n        apply: util.deprecate((...args) => {\n          this.resolverFactory.plugin(\"resolver context\", resolver => {\n            resolver.apply(...args);\n          });\n        }, \"webpack: Using compiler.resolvers.context is deprecated.\\n\" + 'Use compiler.resolverFactory.plugin(\"resolver context\", resolver => {\\n  resolver.apply(/* … */);\\n}); instead.')\n      }\n    };\n\n    /** @type {WebpackOptions} */\n    this.options = /** @type {WebpackOptions} */{};\n    this.context = context;\n    this.requestShortener = new RequestShortener(context);\n\n    /** @type {boolean} */\n    this.running = false;\n\n    /** @type {boolean} */\n    this.watchMode = false;\n\n    /** @private @type {WeakMap<Source, { sizeOnlySource: SizeOnlySource, writtenTo: Map<string, number> }>} */\n    this._assetEmittingSourceCache = new WeakMap();\n    /** @private @type {Map<string, number>} */\n    this._assetEmittingWrittenFiles = new Map();\n  }\n  watch(watchOptions, handler) {\n    if (this.running) return handler(new ConcurrentCompilationError());\n    this.running = true;\n    this.watchMode = true;\n    this.fileTimestamps = new Map();\n    this.contextTimestamps = new Map();\n    this.removedFiles = new Set();\n    return new Watching(this, watchOptions, handler);\n  }\n  run(callback) {\n    if (this.running) return callback(new ConcurrentCompilationError());\n    const finalCallback = (err, stats) => {\n      this.running = false;\n      if (err) {\n        this.hooks.failed.call(err);\n      }\n      if (callback !== undefined) return callback(err, stats);\n    };\n    const startTime = Date.now();\n    this.running = true;\n    const onCompiled = (err, compilation) => {\n      if (err) return finalCallback(err);\n      if (this.hooks.shouldEmit.call(compilation) === false) {\n        const stats = new Stats(compilation);\n        stats.startTime = startTime;\n        stats.endTime = Date.now();\n        this.hooks.done.callAsync(stats, err => {\n          if (err) return finalCallback(err);\n          return finalCallback(null, stats);\n        });\n        return;\n      }\n      this.emitAssets(compilation, err => {\n        if (err) return finalCallback(err);\n        if (compilation.hooks.needAdditionalPass.call()) {\n          compilation.needAdditionalPass = true;\n          const stats = new Stats(compilation);\n          stats.startTime = startTime;\n          stats.endTime = Date.now();\n          this.hooks.done.callAsync(stats, err => {\n            if (err) return finalCallback(err);\n            this.hooks.additionalPass.callAsync(err => {\n              if (err) return finalCallback(err);\n              this.compile(onCompiled);\n            });\n          });\n          return;\n        }\n        this.emitRecords(err => {\n          if (err) return finalCallback(err);\n          const stats = new Stats(compilation);\n          stats.startTime = startTime;\n          stats.endTime = Date.now();\n          this.hooks.done.callAsync(stats, err => {\n            if (err) return finalCallback(err);\n            return finalCallback(null, stats);\n          });\n        });\n      });\n    };\n    this.hooks.beforeRun.callAsync(this, err => {\n      if (err) return finalCallback(err);\n      this.hooks.run.callAsync(this, err => {\n        if (err) return finalCallback(err);\n        this.readRecords(err => {\n          if (err) return finalCallback(err);\n          this.compile(onCompiled);\n        });\n      });\n    });\n  }\n  runAsChild(callback) {\n    this.compile((err, compilation) => {\n      if (err) return callback(err);\n      this.parentCompilation.children.push(compilation);\n      for (const name of Object.keys(compilation.assets)) {\n        this.parentCompilation.assets[name] = compilation.assets[name];\n      }\n      const entries = Array.from(compilation.entrypoints.values(), ep => ep.chunks).reduce((array, chunks) => {\n        return array.concat(chunks);\n      }, []);\n      return callback(null, entries, compilation);\n    });\n  }\n  purgeInputFileSystem() {\n    if (this.inputFileSystem && this.inputFileSystem.purge) {\n      this.inputFileSystem.purge();\n    }\n  }\n  emitAssets(compilation, callback) {\n    let outputPath;\n    const emitFiles = err => {\n      if (err) return callback(err);\n      asyncLib.forEachLimit(compilation.assets, 15, (source, file, callback) => {\n        let targetFile = file;\n        const queryStringIdx = targetFile.indexOf(\"?\");\n        if (queryStringIdx >= 0) {\n          targetFile = targetFile.substr(0, queryStringIdx);\n        }\n        const writeOut = err => {\n          if (err) return callback(err);\n          const targetPath = this.outputFileSystem.join(outputPath, targetFile);\n          // TODO webpack 5 remove futureEmitAssets option and make it on by default\n          if (this.options.output.futureEmitAssets) {\n            // check if the target file has already been written by this Compiler\n            const targetFileGeneration = this._assetEmittingWrittenFiles.get(targetPath);\n\n            // create an cache entry for this Source if not already existing\n            let cacheEntry = this._assetEmittingSourceCache.get(source);\n            if (cacheEntry === undefined) {\n              cacheEntry = {\n                sizeOnlySource: undefined,\n                writtenTo: new Map()\n              };\n              this._assetEmittingSourceCache.set(source, cacheEntry);\n            }\n\n            // if the target file has already been written\n            if (targetFileGeneration !== undefined) {\n              // check if the Source has been written to this target file\n              const writtenGeneration = cacheEntry.writtenTo.get(targetPath);\n              if (writtenGeneration === targetFileGeneration) {\n                // if yes, we skip writing the file\n                // as it's already there\n                // (we assume one doesn't remove files while the Compiler is running)\n                return callback();\n              }\n            }\n\n            // get the binary (Buffer) content from the Source\n            /** @type {Buffer} */\n            let content;\n            if (typeof source.buffer === \"function\") {\n              content = source.buffer();\n            } else {\n              const bufferOrString = source.source();\n              if (Buffer.isBuffer(bufferOrString)) {\n                content = bufferOrString;\n              } else {\n                content = Buffer.from(bufferOrString, \"utf8\");\n              }\n            }\n\n            // Create a replacement resource which only allows to ask for size\n            // This allows to GC all memory allocated by the Source\n            // (expect when the Source is stored in any other cache)\n            cacheEntry.sizeOnlySource = new SizeOnlySource(content.length);\n            compilation.assets[file] = cacheEntry.sizeOnlySource;\n\n            // Write the file to output file system\n            this.outputFileSystem.writeFile(targetPath, content, err => {\n              if (err) return callback(err);\n\n              // information marker that the asset has been emitted\n              compilation.emittedAssets.add(file);\n\n              // cache the information that the Source has been written to that location\n              const newGeneration = targetFileGeneration === undefined ? 1 : targetFileGeneration + 1;\n              cacheEntry.writtenTo.set(targetPath, newGeneration);\n              this._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n              callback();\n            });\n          } else {\n            if (source.existsAt === targetPath) {\n              source.emitted = false;\n              return callback();\n            }\n            let content = source.source();\n            if (!Buffer.isBuffer(content)) {\n              content = Buffer.from(content, \"utf8\");\n            }\n            source.existsAt = targetPath;\n            source.emitted = true;\n            this.outputFileSystem.writeFile(targetPath, content, callback);\n          }\n        };\n        if (targetFile.match(/\\/|\\\\/)) {\n          const dir = path.dirname(targetFile);\n          this.outputFileSystem.mkdirp(this.outputFileSystem.join(outputPath, dir), writeOut);\n        } else {\n          writeOut();\n        }\n      }, err => {\n        if (err) return callback(err);\n        this.hooks.afterEmit.callAsync(compilation, err => {\n          if (err) return callback(err);\n          return callback();\n        });\n      });\n    };\n    this.hooks.emit.callAsync(compilation, err => {\n      if (err) return callback(err);\n      outputPath = compilation.getPath(this.outputPath);\n      this.outputFileSystem.mkdirp(outputPath, emitFiles);\n    });\n  }\n  emitRecords(callback) {\n    if (!this.recordsOutputPath) return callback();\n    const idx1 = this.recordsOutputPath.lastIndexOf(\"/\");\n    const idx2 = this.recordsOutputPath.lastIndexOf(\"\\\\\");\n    let recordsOutputPathDirectory = null;\n    if (idx1 > idx2) {\n      recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx1);\n    } else if (idx1 < idx2) {\n      recordsOutputPathDirectory = this.recordsOutputPath.substr(0, idx2);\n    }\n    const writeFile = () => {\n      this.outputFileSystem.writeFile(this.recordsOutputPath, JSON.stringify(this.records, undefined, 2), callback);\n    };\n    if (!recordsOutputPathDirectory) {\n      return writeFile();\n    }\n    this.outputFileSystem.mkdirp(recordsOutputPathDirectory, err => {\n      if (err) return callback(err);\n      writeFile();\n    });\n  }\n  readRecords(callback) {\n    if (!this.recordsInputPath) {\n      this.records = {};\n      return callback();\n    }\n    this.inputFileSystem.stat(this.recordsInputPath, err => {\n      // It doesn't exist\n      // We can ignore this.\n      if (err) return callback();\n      this.inputFileSystem.readFile(this.recordsInputPath, (err, content) => {\n        if (err) return callback(err);\n        try {\n          this.records = parseJson(content.toString(\"utf-8\"));\n        } catch (e) {\n          e.message = \"Cannot parse records: \" + e.message;\n          return callback(e);\n        }\n        return callback();\n      });\n    });\n  }\n  createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {\n    const childCompiler = new Compiler(this.context);\n    if (Array.isArray(plugins)) {\n      for (const plugin of plugins) {\n        plugin.apply(childCompiler);\n      }\n    }\n    for (const name in this.hooks) {\n      if (![\"make\", \"compile\", \"emit\", \"afterEmit\", \"invalid\", \"done\", \"thisCompilation\"].includes(name)) {\n        if (childCompiler.hooks[name]) {\n          childCompiler.hooks[name].taps = this.hooks[name].taps.slice();\n        }\n      }\n    }\n    childCompiler.name = compilerName;\n    childCompiler.outputPath = this.outputPath;\n    childCompiler.inputFileSystem = this.inputFileSystem;\n    childCompiler.outputFileSystem = null;\n    childCompiler.resolverFactory = this.resolverFactory;\n    childCompiler.fileTimestamps = this.fileTimestamps;\n    childCompiler.contextTimestamps = this.contextTimestamps;\n    const relativeCompilerName = makePathsRelative(this.context, compilerName);\n    if (!this.records[relativeCompilerName]) {\n      this.records[relativeCompilerName] = [];\n    }\n    if (this.records[relativeCompilerName][compilerIndex]) {\n      childCompiler.records = this.records[relativeCompilerName][compilerIndex];\n    } else {\n      this.records[relativeCompilerName].push(childCompiler.records = {});\n    }\n    childCompiler.options = Object.create(this.options);\n    childCompiler.options.output = Object.create(childCompiler.options.output);\n    for (const name in outputOptions) {\n      childCompiler.options.output[name] = outputOptions[name];\n    }\n    childCompiler.parentCompilation = compilation;\n    compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);\n    return childCompiler;\n  }\n  isChild() {\n    return !!this.parentCompilation;\n  }\n  createCompilation() {\n    return new Compilation(this);\n  }\n  newCompilation(params) {\n    const compilation = this.createCompilation();\n    compilation.fileTimestamps = this.fileTimestamps;\n    compilation.contextTimestamps = this.contextTimestamps;\n    compilation.name = this.name;\n    compilation.records = this.records;\n    compilation.compilationDependencies = params.compilationDependencies;\n    this.hooks.thisCompilation.call(compilation, params);\n    this.hooks.compilation.call(compilation, params);\n    return compilation;\n  }\n  createNormalModuleFactory() {\n    const normalModuleFactory = new NormalModuleFactory(this.options.context, this.resolverFactory, this.options.module || {});\n    this.hooks.normalModuleFactory.call(normalModuleFactory);\n    return normalModuleFactory;\n  }\n  createContextModuleFactory() {\n    const contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n    this.hooks.contextModuleFactory.call(contextModuleFactory);\n    return contextModuleFactory;\n  }\n  newCompilationParams() {\n    const params = {\n      normalModuleFactory: this.createNormalModuleFactory(),\n      contextModuleFactory: this.createContextModuleFactory(),\n      compilationDependencies: new Set()\n    };\n    return params;\n  }\n  compile(callback) {\n    const params = this.newCompilationParams();\n    this.hooks.beforeCompile.callAsync(params, err => {\n      if (err) return callback(err);\n      this.hooks.compile.call(params);\n      const compilation = this.newCompilation(params);\n      this.hooks.make.callAsync(compilation, err => {\n        if (err) return callback(err);\n        compilation.finish();\n        compilation.seal(err => {\n          if (err) return callback(err);\n          this.hooks.afterCompile.callAsync(compilation, err => {\n            if (err) return callback(err);\n            return callback(null, compilation);\n          });\n        });\n      });\n    });\n  }\n}\nmodule.exports = Compiler;\nclass SizeOnlySource extends Source {\n  constructor(size) {\n    super();\n    this._size = size;\n  }\n  _error() {\n    return new Error(\"Content and Map of this Source is no longer available (only size() is supported)\");\n  }\n  size() {\n    return this._size;\n  }\n\n  /**\n   * @param {any} options options\n   * @returns {string} the source\n   */\n  source(options) {\n    throw this._error();\n  }\n  node() {\n    throw this._error();\n  }\n  listMap() {\n    throw this._error();\n  }\n  map() {\n    throw this._error();\n  }\n  listNode() {\n    throw this._error();\n  }\n  updateHash() {\n    throw this._error();\n  }\n}","map":null,"metadata":{},"sourceType":"script"}