{"ast":null,"code":"/*\n MIT License http://www.opensource.org/licenses/mit-license.php\n Author Tobias Koppers @sokra\n */\n\n\"use strict\";\n\nconst {\n  ConcatSource\n} = require(\"webpack-sources\");\nconst ModuleFilenameHelpers = require(\"./ModuleFilenameHelpers\");\nconst Template = require(\"./Template\");\nconst validateOptions = require(\"schema-utils\");\nconst schema = require(\"../schemas/plugins/BannerPlugin.json\");\n\n/** @typedef {import(\"../declarations/plugins/BannerPlugin\").BannerPluginArgument} BannerPluginArgument */\n/** @typedef {import(\"../declarations/plugins/BannerPlugin\").BannerPluginOptions} BannerPluginOptions */\n\nconst wrapComment = str => {\n  if (!str.includes(\"\\n\")) {\n    return Template.toComment(str);\n  }\n  return `/*!\\n * ${str.replace(/\\*\\//g, \"* /\").split(\"\\n\").join(\"\\n * \")}\\n */`;\n};\nclass BannerPlugin {\n  /**\n   * @param {BannerPluginArgument} options options object\n   */\n  constructor(options) {\n    if (arguments.length > 1) {\n      throw new Error(\"BannerPlugin only takes one argument (pass an options object)\");\n    }\n    validateOptions(schema, options, \"Banner Plugin\");\n    if (typeof options === \"string\" || typeof options === \"function\") {\n      options = {\n        banner: options\n      };\n    }\n\n    /** @type {BannerPluginOptions} */\n    this.options = options;\n    const bannerOption = options.banner;\n    if (typeof bannerOption === \"function\") {\n      const getBanner = bannerOption;\n      this.banner = this.options.raw ? getBanner : data => wrapComment(getBanner(data));\n    } else {\n      const banner = this.options.raw ? bannerOption : wrapComment(bannerOption);\n      this.banner = () => banner;\n    }\n  }\n  apply(compiler) {\n    const options = this.options;\n    const banner = this.banner;\n    const matchObject = ModuleFilenameHelpers.matchObject.bind(undefined, options);\n    compiler.hooks.compilation.tap(\"BannerPlugin\", compilation => {\n      compilation.hooks.optimizeChunkAssets.tap(\"BannerPlugin\", chunks => {\n        for (const chunk of chunks) {\n          if (options.entryOnly && !chunk.canBeInitial()) {\n            continue;\n          }\n          for (const file of chunk.files) {\n            if (!matchObject(file)) {\n              continue;\n            }\n            let basename;\n            let query = \"\";\n            let filename = file;\n            const hash = compilation.hash;\n            const querySplit = filename.indexOf(\"?\");\n            if (querySplit >= 0) {\n              query = filename.substr(querySplit);\n              filename = filename.substr(0, querySplit);\n            }\n            const lastSlashIndex = filename.lastIndexOf(\"/\");\n            if (lastSlashIndex === -1) {\n              basename = filename;\n            } else {\n              basename = filename.substr(lastSlashIndex + 1);\n            }\n            const data = {\n              hash,\n              chunk,\n              filename,\n              basename,\n              query\n            };\n            const comment = compilation.getPath(banner(data), data);\n            compilation.assets[file] = new ConcatSource(comment, \"\\n\", compilation.assets[file]);\n          }\n        }\n      });\n    });\n  }\n}\nmodule.exports = BannerPlugin;","map":null,"metadata":{},"sourceType":"script"}