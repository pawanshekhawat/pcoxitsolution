{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst util = require(\"util\");\nconst DependenciesBlock = require(\"./DependenciesBlock\");\nconst ModuleReason = require(\"./ModuleReason\");\nconst SortableSet = require(\"./util/SortableSet\");\nconst Template = require(\"./Template\");\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./RequestShortener\")} RequestShortener */\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./util/createHash\").Hash} Hash */\n\nconst EMPTY_RESOLVE_OPTIONS = {};\nlet debugId = 1000;\nconst sortById = (a, b) => {\n  return a.id - b.id;\n};\nconst sortByDebugId = (a, b) => {\n  return a.debugId - b.debugId;\n};\n\n/** @typedef {(requestShortener: RequestShortener) => string} OptimizationBailoutFunction */\n\nclass Module extends DependenciesBlock {\n  constructor(type, context = null) {\n    super();\n    /** @type {string} */\n    this.type = type;\n    /** @type {string} */\n    this.context = context;\n\n    // Unique Id\n    /** @type {number} */\n    this.debugId = debugId++;\n\n    // Hash\n    /** @type {string} */\n    this.hash = undefined;\n    /** @type {string} */\n    this.renderedHash = undefined;\n\n    // Info from Factory\n    /** @type {TODO} */\n    this.resolveOptions = EMPTY_RESOLVE_OPTIONS;\n    /** @type {object} */\n    this.factoryMeta = {};\n\n    // Info from Build\n    /** @type {WebpackError[]} */\n    this.warnings = [];\n    /** @type {WebpackError[]} */\n    this.errors = [];\n    /** @type {object} */\n    this.buildMeta = undefined;\n    /** @type {object} */\n    this.buildInfo = undefined;\n\n    // Graph (per Compilation)\n    /** @type {ModuleReason[]} */\n    this.reasons = [];\n    /** @type {SortableSet<Chunk>} */\n    this._chunks = new SortableSet(undefined, sortById);\n\n    // Info from Compilation (per Compilation)\n    /** @type {number|string} */\n    this.id = null;\n    /** @type {number} */\n    this.index = null;\n    /** @type {number} */\n    this.index2 = null;\n    /** @type {number} */\n    this.depth = null;\n    /** @type {Module} */\n    this.issuer = null;\n    /** @type {undefined | object} */\n    this.profile = undefined;\n    /** @type {boolean} */\n    this.prefetched = false;\n    /** @type {boolean} */\n    this.built = false;\n\n    // Info from Optimization (per Compilation)\n    /** @type {null | boolean} */\n    this.used = null;\n    /** @type {false | true | string[]} */\n    this.usedExports = null;\n    /** @type {(string | OptimizationBailoutFunction)[]} */\n    this.optimizationBailout = [];\n\n    // delayed operations\n    /** @type {undefined | {oldChunk: Chunk, newChunks: Chunk[]}[] } */\n    this._rewriteChunkInReasons = undefined;\n\n    /** @type {boolean} */\n    this.useSourceMap = false;\n\n    // info from build\n    this._source = null;\n  }\n  get exportsArgument() {\n    return this.buildInfo && this.buildInfo.exportsArgument || \"exports\";\n  }\n  get moduleArgument() {\n    return this.buildInfo && this.buildInfo.moduleArgument || \"module\";\n  }\n  disconnect() {\n    this.hash = undefined;\n    this.renderedHash = undefined;\n    this.reasons.length = 0;\n    this._rewriteChunkInReasons = undefined;\n    this._chunks.clear();\n    this.id = null;\n    this.index = null;\n    this.index2 = null;\n    this.depth = null;\n    this.issuer = null;\n    this.profile = undefined;\n    this.prefetched = false;\n    this.built = false;\n    this.used = null;\n    this.usedExports = null;\n    this.optimizationBailout.length = 0;\n    super.disconnect();\n  }\n  unseal() {\n    this.id = null;\n    this.index = null;\n    this.index2 = null;\n    this.depth = null;\n    this._chunks.clear();\n    super.unseal();\n  }\n  setChunks(chunks) {\n    this._chunks = new SortableSet(chunks, sortById);\n  }\n  addChunk(chunk) {\n    if (this._chunks.has(chunk)) return false;\n    this._chunks.add(chunk);\n    return true;\n  }\n  removeChunk(chunk) {\n    if (this._chunks.delete(chunk)) {\n      chunk.removeModule(this);\n      return true;\n    }\n    return false;\n  }\n  isInChunk(chunk) {\n    return this._chunks.has(chunk);\n  }\n  isEntryModule() {\n    for (const chunk of this._chunks) {\n      if (chunk.entryModule === this) return true;\n    }\n    return false;\n  }\n  get optional() {\n    return this.reasons.length > 0 && this.reasons.every(r => r.dependency && r.dependency.optional);\n  }\n\n  /**\n   * @returns {Chunk[]} all chunks which contain the module\n   */\n  getChunks() {\n    return Array.from(this._chunks);\n  }\n  getNumberOfChunks() {\n    return this._chunks.size;\n  }\n  get chunksIterable() {\n    return this._chunks;\n  }\n  hasEqualsChunks(otherModule) {\n    if (this._chunks.size !== otherModule._chunks.size) return false;\n    this._chunks.sortWith(sortByDebugId);\n    otherModule._chunks.sortWith(sortByDebugId);\n    const a = this._chunks[Symbol.iterator]();\n    const b = otherModule._chunks[Symbol.iterator]();\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      const aItem = a.next();\n      const bItem = b.next();\n      if (aItem.done) return true;\n      if (aItem.value !== bItem.value) return false;\n    }\n  }\n  addReason(module, dependency, explanation) {\n    this.reasons.push(new ModuleReason(module, dependency, explanation));\n  }\n  removeReason(module, dependency) {\n    for (let i = 0; i < this.reasons.length; i++) {\n      let r = this.reasons[i];\n      if (r.module === module && r.dependency === dependency) {\n        this.reasons.splice(i, 1);\n        return true;\n      }\n    }\n    return false;\n  }\n  hasReasonForChunk(chunk) {\n    if (this._rewriteChunkInReasons) {\n      for (const operation of this._rewriteChunkInReasons) {\n        this._doRewriteChunkInReasons(operation.oldChunk, operation.newChunks);\n      }\n      this._rewriteChunkInReasons = undefined;\n    }\n    for (let i = 0; i < this.reasons.length; i++) {\n      if (this.reasons[i].hasChunk(chunk)) return true;\n    }\n    return false;\n  }\n  hasReasons() {\n    return this.reasons.length > 0;\n  }\n  rewriteChunkInReasons(oldChunk, newChunks) {\n    // This is expensive. Delay operation until we really need the data\n    if (this._rewriteChunkInReasons === undefined) {\n      this._rewriteChunkInReasons = [];\n    }\n    this._rewriteChunkInReasons.push({\n      oldChunk,\n      newChunks\n    });\n  }\n  _doRewriteChunkInReasons(oldChunk, newChunks) {\n    for (let i = 0; i < this.reasons.length; i++) {\n      this.reasons[i].rewriteChunks(oldChunk, newChunks);\n    }\n  }\n\n  /**\n   * @param {string=} exportName the name of the export\n   * @returns {boolean|string} false if the export isn't used, true if no exportName is provided and the module is used, or the name to access it if the export is used\n   */\n  isUsed(exportName) {\n    if (!exportName) return this.used !== false;\n    if (this.used === null || this.usedExports === null) return exportName;\n    if (!this.used) return false;\n    if (!this.usedExports) return false;\n    if (this.usedExports === true) return exportName;\n    let idx = this.usedExports.indexOf(exportName);\n    if (idx < 0) return false;\n\n    // Mangle export name if possible\n    if (this.isProvided(exportName)) {\n      if (this.buildMeta.exportsType === \"namespace\") {\n        return Template.numberToIdentifer(idx);\n      }\n      if (this.buildMeta.exportsType === \"named\" && !this.usedExports.includes(\"default\")) {\n        return Template.numberToIdentifer(idx);\n      }\n    }\n    return exportName;\n  }\n  isProvided(exportName) {\n    if (!Array.isArray(this.buildMeta.providedExports)) return null;\n    return this.buildMeta.providedExports.includes(exportName);\n  }\n  toString() {\n    return `Module[${this.id || this.debugId}]`;\n  }\n  needRebuild(fileTimestamps, contextTimestamps) {\n    return true;\n  }\n\n  /**\n   * @param {Hash} hash the hash used to track dependencies\n   * @returns {void}\n   */\n  updateHash(hash) {\n    hash.update(`${this.id}`);\n    hash.update(JSON.stringify(this.usedExports));\n    super.updateHash(hash);\n  }\n  sortItems(sortChunks) {\n    super.sortItems();\n    if (sortChunks) this._chunks.sort();\n    this.reasons.sort((a, b) => {\n      if (a.module === b.module) return 0;\n      if (!a.module) return -1;\n      if (!b.module) return 1;\n      return sortById(a.module, b.module);\n    });\n    if (Array.isArray(this.usedExports)) {\n      this.usedExports.sort();\n    }\n  }\n  unbuild() {\n    this.dependencies.length = 0;\n    this.blocks.length = 0;\n    this.variables.length = 0;\n    this.buildMeta = undefined;\n    this.buildInfo = undefined;\n    this.disconnect();\n  }\n  get arguments() {\n    throw new Error(\"Module.arguments was removed, there is no replacement.\");\n  }\n  set arguments(value) {\n    throw new Error(\"Module.arguments was removed, there is no replacement.\");\n  }\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Module.prototype, \"forEachChunk\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {function(any, any, Set<any>): void} fn callback function\n   * @returns {void}\n   * @this {Module}\n   */\n  function (fn) {\n    this._chunks.forEach(fn);\n  }, \"Module.forEachChunk: Use for(const chunk of module.chunksIterable) instead\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Module.prototype, \"mapChunks\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {function(any, any): void} fn Mapper function\n   * @returns {Array<TODO>} Array of chunks mapped\n   * @this {Module}\n   */\n  function (fn) {\n    return Array.from(this._chunks, fn);\n  }, \"Module.mapChunks: Use Array.from(module.chunksIterable, fn) instead\")\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Module.prototype, \"entry\", {\n  configurable: false,\n  get() {\n    throw new Error(\"Module.entry was removed. Use Chunk.entryModule\");\n  },\n  set() {\n    throw new Error(\"Module.entry was removed. Use Chunk.entryModule\");\n  }\n});\n\n// TODO remove in webpack 5\nObject.defineProperty(Module.prototype, \"meta\", {\n  configurable: false,\n  get: util.deprecate(\n  /**\n   * @deprecated\n   * @returns {void}\n   * @this {Module}\n   */\n  function () {\n    return this.buildMeta;\n  }, \"Module.meta was renamed to Module.buildMeta\"),\n  set: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} value Value\n   * @returns {void}\n   * @this {Module}\n   */\n  function (value) {\n    this.buildMeta = value;\n  }, \"Module.meta was renamed to Module.buildMeta\")\n});\n\n/** @type {function(): string} */\nModule.prototype.identifier = null;\n\n/** @type {function(RequestShortener): string} */\nModule.prototype.readableIdentifier = null;\nModule.prototype.build = null;\nModule.prototype.source = null;\nModule.prototype.size = null;\nModule.prototype.nameForCondition = null;\n/** @type {null | function(Chunk): boolean} */\nModule.prototype.chunkCondition = null;\nModule.prototype.updateCacheModule = null;\nmodule.exports = Module;","map":null,"metadata":{},"sourceType":"script"}