{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nclass FlagIncludedChunksPlugin {\n  apply(compiler) {\n    compiler.hooks.compilation.tap(\"FlagIncludedChunksPlugin\", compilation => {\n      compilation.hooks.optimizeChunkIds.tap(\"FlagIncludedChunksPlugin\", chunks => {\n        // prepare two bit integers for each module\n        // 2^31 is the max number represented as SMI in v8\n        // we want the bits distributed this way:\n        // the bit 2^31 is pretty rar and only one module should get it\n        // so it has a probability of 1 / modulesCount\n        // the first bit (2^0) is the easiest and every module could get it\n        // if it doesn't get a better bit\n        // from bit 2^n to 2^(n+1) there is a probability of p\n        // so 1 / modulesCount == p^31\n        // <=> p = sqrt31(1 / modulesCount)\n        // so we use a modulo of 1 / sqrt31(1 / modulesCount)\n        const moduleBits = new WeakMap();\n        const modulesCount = compilation.modules.length;\n\n        // precalculate the modulo values for each bit\n        const modulo = 1 / Math.pow(1 / modulesCount, 1 / 31);\n        const modulos = Array.from({\n          length: 31\n        }, (x, i) => Math.pow(modulo, i) | 0);\n\n        // iterate all modules to generate bit values\n        let i = 0;\n        for (const module of compilation.modules) {\n          let bit = 30;\n          while (i % modulos[bit] !== 0) {\n            bit--;\n          }\n          moduleBits.set(module, 1 << bit);\n          i++;\n        }\n\n        // interate all chunks to generate bitmaps\n        const chunkModulesHash = new WeakMap();\n        for (const chunk of chunks) {\n          let hash = 0;\n          for (const module of chunk.modulesIterable) {\n            hash |= moduleBits.get(module);\n          }\n          chunkModulesHash.set(chunk, hash);\n        }\n        for (const chunkA of chunks) {\n          const chunkAHash = chunkModulesHash.get(chunkA);\n          const chunkAModulesCount = chunkA.getNumberOfModules();\n          if (chunkAModulesCount === 0) continue;\n          let bestModule = undefined;\n          for (const module of chunkA.modulesIterable) {\n            if (bestModule === undefined || bestModule.getNumberOfChunks() > module.getNumberOfChunks()) bestModule = module;\n          }\n          loopB: for (const chunkB of bestModule.chunksIterable) {\n            // as we iterate the same iterables twice\n            // skip if we find ourselves\n            if (chunkA === chunkB) continue;\n            const chunkBModulesCount = chunkB.getNumberOfModules();\n\n            // ids for empty chunks are not included\n            if (chunkBModulesCount === 0) continue;\n\n            // instead of swapping A and B just bail\n            // as we loop twice the current A will be B and B then A\n            if (chunkAModulesCount > chunkBModulesCount) continue;\n\n            // is chunkA in chunkB?\n\n            // we do a cheap check for the hash value\n            const chunkBHash = chunkModulesHash.get(chunkB);\n            if ((chunkBHash & chunkAHash) !== chunkAHash) continue;\n\n            // compare all modules\n            for (const m of chunkA.modulesIterable) {\n              if (!chunkB.containsModule(m)) continue loopB;\n            }\n            chunkB.ids.push(chunkA.id);\n          }\n        }\n      });\n    });\n  }\n}\nmodule.exports = FlagIncludedChunksPlugin;","map":null,"metadata":{},"sourceType":"script"}